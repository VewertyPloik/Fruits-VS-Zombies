<!DOCTYPE html>
<html lang="en" >
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Fruits vs Zombies - Green Grid</title>
  <style>
    :root {
      --green: #3a8d3a;
      --darkgreen: #2a6b2a;
      --lightgreen: #a0d080;
      --accent: #2b9fff;
      --red: #ef4444;
      --yellow: #facc15;
      --blue: #3b82f6;
      --font: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
    }
    * {
      box-sizing: border-box;
    }
    body {
      margin: 0; 
      min-height: 100vh;
      font-family: var(--font);
      background: linear-gradient(to bottom, #e6fbff 0%, #f2fff9 100%);
      display: flex;
      justify-content: center;
      padding: 10px 0;
      user-select: none;
    }
    #app {
      background: #ffffffee;
      border-radius: 14px;
      width: 100%;
      max-width: 520px;
      box-shadow: 0 12px 40px rgba(6,30,60,0.12);
      display: flex;
      flex-direction: column;
      height: 100vh;
      max-height: 760px;
    }
    header {
      padding: 10px 12px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      background: var(--lightgreen);
      border-bottom: 2px solid var(--darkgreen);
      font-weight: 700;
      color: var(--darkgreen);
      font-size: 14px;
      user-select:none;
    }
    header > div {
      display: flex;
      gap: 15px;
      align-items: center;
    }
    #board {
      position: relative;
      flex: 1;
      background:
        linear-gradient(var(--darkgreen) 2px, transparent 2px),
        linear-gradient(90deg, var(--darkgreen) 2px, transparent 2px);
      background-size: calc(100% / 4) calc(100% / 3);
      touch-action: none;
      user-select:none;
      border-radius: 10px;
      margin: 10px 12px 6px;
    }
    #grid {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      grid-template-rows: repeat(3, 1fr);
      width: 100%;
      height: 100%;
      position: relative;
    }
    .cell {
      position: relative;
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 44px;
      user-select:none;
      cursor: pointer;
      transition: background-color 0.2s ease;
      /* highlight on tap */
    }
    .cell:hover {
      background: rgba(170, 230, 170, 0.25);
    }
    .hpbar {
      position: absolute;
      bottom: 4px;
      left: 12px;
      right: 12px;
      height: 6px;
      border-radius: 9999px;
      background: rgba(0,0,0,0.1);
      overflow: hidden;
    }
    .hpfill {
      height: 100%;
      background: linear-gradient(90deg, #34d399, #059669);
      width: 100%;
      transition: width 0.3s ease;
    }
    .zombie-hpbar {
      position: absolute;
      bottom: 12px;
      width: 44px;
      height: 6px;
      border-radius: 9999px;
      background: rgba(0,0,0,0.1);
      overflow: hidden;
    }
    .zombie-hpfill {
      height: 100%;
      background: linear-gradient(90deg, #fb7185, #ef4444);
      width: 100%;
      transition: width 0.3s ease;
    }
    #toolbar {
      display: flex;
      gap: 10px;
      padding: 0 12px 12px;
      justify-content: center;
      user-select:none;
    }
    .toolBtn {
      font-size: 30px;
      background: transparent;
      border: 2.8px solid transparent;
      border-radius: 10px;
      padding: 6px 12px 4px;
      cursor: pointer;
      user-select:none;
      display: flex;
      flex-direction: column;
      align-items: center;
      color: var(--darkgreen);
      font-weight: 700;
      width: 56px;
    }
    .toolBtn span {
      font-size: 14px;
      margin-top: 2px;
      user-select:none;
      pointer-events:none;
    }
    .toolBtn.selected {
      border-color: var(--accent);
      color: var(--accent);
    }
    #infoBar {
      display: flex;
      justify-content: space-between;
      padding: 0 12px 8px;
      font-weight: 600;
      font-size: 15px;
      color: var(--darkgreen);
      user-select:none;
    }
    #controls {
      display: flex;
      justify-content: center;
      gap: 14px;
      padding-bottom: 10px;
      user-select:none;
    }
    button.btn {
      background: var(--accent);
      color: white;
      font-weight: 700;
      border: none;
      border-radius: 12px;
      padding: 8px 18px;
      font-size: 16px;
      cursor: pointer;
      user-select:none;
      transition: background-color 0.2s ease;
      min-width: 90px;
    }
    button.btn:hover:not(:disabled) {
      background: #0071d1;
    }
    button.btn:disabled {
      opacity: 0.5;
      cursor: default;
    }
    #centerMsg {
      position: absolute;
      left: 50%;
      top: 40%;
      transform: translateX(-50%);
      background: rgba(255 255 255 / 0.95);
      padding: 14px 24px;
      border-radius: 16px;
      font-weight: 800;
      font-size: 18px;
      color: var(--darkgreen);
      pointer-events:none;
      user-select:none;
      display: none;
      z-index: 50;
      box-shadow: 0 6px 22px rgba(8,20,40,0.12);
      text-align: center;
    }
    /* Responsive */
    @media (max-width: 420px) {
      #app { max-height: 100vh; }
      .cell {
        font-size: 36px;
      }
      .toolBtn {
        width: 48px;
        font-size: 26px;
      }
      .toolBtn span {
        font-size: 12px;
      }
    }
  </style>
</head>
<body>
  <div id="app" role="main" aria-label="Fruits vs Zombies game">
    <header aria-live="polite">
      <div>
        <span id="waveDisplay">Wave 1 / 15</span>
        <span id="zombiesLeft">Zombies: 0</span>
      </div>
      <div>
        <span>üíß <span id="coinsDisplay">15</span></span>
        <span>‚ù§Ô∏è <span id="healthDisplay">5</span></span>
      </div>
    </header>

    <div id="board" aria-label="Game board">
      <div id="grid" aria-label="Game grid"></div>
      <div id="centerMsg" aria-live="assertive"></div>
    </div>

    <div id="toolbar" aria-label="Select fruit to place"></div>

    <div id="infoBar" aria-live="polite">
      Tap rain drops üíß to collect coins. Fruits have 4 HP. Zombies must chew fruits to advance.
    </div>

    <div id="controls">
      <button id="pauseBtn" class="btn" aria-pressed="false">Pause</button>
      <button id="newGameBtn" class="btn">New Game</button>
    </div>
  </div>

<script>
(() => {
  // CONFIG
  const ROWS = 3, COLS = 4, MAX_WAVE = 15;
  const START_COINS = 15, START_HEALTH = 5;
  const FRUIT_HP = 4;
  const RAIN_INTERVAL_MS = 4000;
  const RAIN_VALUE = 1;
  const ZOMBIE_BASE_HP = 5;
  const ZOMBIE_HP_PER_WAVE = 2;
  const ZOMBIE_BASE_SPEED = 30; // px per second, wave 1 base speed
  const ZOMBIE_SPEED_MULT_PER_WAVE = 1.08;
  const SPAWN_BASE = 3;
  const SPAWN_INC = 3;
  const ZOMBIE_BITE_INTERVAL = 0.8; // seconds per bite
  const CELL_SIZE = 100; // approx for calculations

  // PLANTS DATA
  const PLANTS = {
    banana: { key: 'banana', emoji: 'üçå', cost: 10, shootMs: 3500, damage: 5, hp: FRUIT_HP },
    lemon: { key: 'lemon', emoji: 'üçã', cost: 8, explodeDmg: 25, explodeRange: 1, hp: FRUIT_HP },
    watermelon: { key: 'watermelon', emoji: 'üçâ', cost: 5, produceMs: 4000, produce: 1, hp: FRUIT_HP },
    blueberry: { key: 'blueberry', emoji: 'ü´ê', cost: 25, shootMs: 2500, damage: 10, hp: FRUIT_HP },
  };

  // STATE
  let state = {
    wave: 1,
    coins: START_COINS,
    health: START_HEALTH,
    grid: Array.from({ length: ROWS }, () => Array(COLS).fill(null)),
    zombies: [], // {x, row, hp, maxHp, speed, attacking, attackTimer, targetCol}
    projectiles: [], // {x, y, row, speed, damage, target}
    rainDrops: [], // {x, y, vy}
    selectedPlant: 'banana',
    running: false,
    paused: false,
    zombiesToSpawn: 0,
    spawnTimer: 0,
    lastRainTime: 0,
    highScore: 0,
  };

  // DOM elements
  const gridEl = document.getElementById('grid');
  const coinsEl = document.getElementById('coinsDisplay');
  const healthEl = document.getElementById('healthDisplay');
  const zombiesLeftEl = document.getElementById('zombiesLeft');
  const waveEl = document.getElementById('waveDisplay');
  const toolbarEl = document.getElementById('toolbar');
  const centerMsgEl = document.getElementById('centerMsg');
  const pauseBtn = document.getElementById('pauseBtn');
  const newGameBtn = document.getElementById('newGameBtn');

  // LOCAL STORAGE KEY
  const HIGH_SCORE_KEY = 'fruitsVsZombiesHighScore';

  // INIT
  function loadHighScore() {
    const hs = parseInt(localStorage.getItem(HIGH_SCORE_KEY) || '0', 10);
    state.highScore = isNaN(hs) ? 0 : hs;
  }
  function saveHighScore() {
    if(state.wave > state.highScore) {
      state.highScore = state.wave;
      localStorage.setItem(HIGH_SCORE_KEY, state.highScore);
    }
  }

  // BUILD GRID DOM with cells & hp bars
  function buildGrid() {
    gridEl.innerHTML = '';
    for(let r = 0; r < ROWS; r++) {
      for(let c = 0; c < COLS; c++) {
        const cell = document.createElement('div');
        cell.classList.add('cell');
        cell.dataset.row = r;
        cell.dataset.col = c;
        cell.setAttribute('aria-label', `Row ${r+1} Column ${c+1} empty`);
        cell.tabIndex = 0;
        cell.addEventListener('click', () => placePlant(r,c));
        // hp bar div
        const hpBar = document.createElement('div');
        hpBar.classList.add('hpbar');
        const hpFill = document.createElement('div');
        hpFill.classList.add('hpfill');
        hpBar.appendChild(hpFill);
        cell.appendChild(hpBar);
        gridEl.appendChild(cell);
      }
    }
    renderGrid();
  }
  // Render grid (plants + hp bars)
  function renderGrid() {
    const cells = gridEl.children;
    for(let i = 0; i < cells.length; i++) {
      const r = Math.floor(i / COLS);
      const c = i % COLS;
      const cell = cells[i];
      const plant = state.grid[r][c];
      const hpFill = cell.querySelector('.hpfill');
      if(!plant) {
        cell.textContent = '';
        cell.setAttribute('aria-label', `Row ${r+1} Column ${c+1} empty`);
        hpFill.style.width = '0%';
        cell.style.color = 'inherit';
      } else {
        cell.textContent = PLANTS[plant.type].emoji;
        cell.appendChild(cell.querySelector('.hpbar')); // reappend for structure
        cell.style.color = 'black';
        const hpPercent = Math.max(0, (plant.hp / PLANTS[plant.type].hp) * 100);
        hpFill.style.width = hpPercent + '%';
        cell.setAttribute('aria-label', `Row ${r+1} Column ${c+1} ${plant.type} with ${Math.round(hpPercent)}% health`);
      }
    }
  }

  // TOOLBAR build buttons
  function buildToolbar() {
    toolbarEl.innerHTML = '';
    Object.values(PLANTS).forEach(plant => {
      const btn = document.createElement('button');
      btn.className = 'toolBtn';
      btn.title = `${plant.emoji} - Cost: ${plant.cost} üíß`;
      btn.textContent = plant.emoji;
      const label = document.createElement('span');
      label.textContent = plant.key;
      btn.appendChild(label);
      btn.addEventListener('click', () => {
        state.selectedPlant = plant.key;
        updateToolbarSelection();
      });
      toolbarEl.appendChild(btn);
    });
    updateToolbarSelection();
  }
  function updateToolbarSelection() {
    [...toolbarEl.children].forEach(btn => {
      if(btn.textContent.includes(PLANTS[state.selectedPlant].emoji)) btn.classList.add('selected');
      else btn.classList.remove('selected');
    });
  }

  // PLACE plant on grid cell if empty and enough coins
  function placePlant(r, c) {
    if(state.paused || !state.running) return;
    if(state.grid[r][c]) return; // occupied
    const plantData = PLANTS[state.selectedPlant];
    if(state.coins < plantData.cost) return;
    state.grid[r][c] = { type: state.selectedPlant, hp: plantData.hp };
    state.coins -= plantData.cost;
    coinsEl.textContent = state.coins;
    renderGrid();
  }

  // ZOMBIE SPAWN and movement
  function spawnZombies() {
    state.zombiesToSpawn = SPAWN_BASE + SPAWN_INC * (state.wave - 1);
    state.spawnTimer = 0;
  }
  function createZombie(row) {
    const maxHp = ZOMBIE_BASE_HP + (ZOMBIE_HP_PER_WAVE * (state.wave - 1));
    const speed = ZOMBIE_BASE_SPEED * Math.pow(ZOMBIE_SPEED_MULT_PER_WAVE, state.wave - 1);
    return {
      x: COLS * CELL_SIZE + 40,
      row,
      hp: maxHp,
      maxHp,
      speed,
      attacking: false,
      attackTimer: 0,
      targetCol: COLS - 1,
    };
  }
  // Update zombies and handle attacking
  function updateZombies(dt) {
    if(state.zombiesToSpawn > 0) {
      state.spawnTimer -= dt;
      if(state.spawnTimer <= 0) {
        // spawn zombie on random row
        const r = Math.floor(Math.random() * ROWS);
        state.zombies.push(createZombie(r));
        state.zombiesToSpawn--;
        state.spawnTimer = 2; // spawn every 2 seconds
      }
    }

    for(let z of state.zombies) {
      if(z.attacking) {
        z.attackTimer -= dt;
        if(z.attackTimer <= 0) {
          const plant = state.grid[z.row][z.targetCol];
          if(plant) {
            plant.hp--;
            if(plant.hp <= 0) {
              state.grid[z.row][z.targetCol] = null;
              renderGrid();
              z.attacking = false;
            }
          }
          z.attackTimer = ZOMBIE_BITE_INTERVAL;
        }
      } else {
        // Move left unless hitting plant
        if(state.grid[z.row][z.targetCol]) {
          // start attacking
          z.attacking = true;
          z.attackTimer = 0;
        } else {
          // move left
          z.x -= z.speed * dt;
          // if passed left boundary => player loses health
          if(z.x < -40) {
            state.health--;
            healthEl.textContent = state.health;
            // Remove zombie
            state.zombies = state.zombies.filter(zm => zm !== z);
            if(state.health <= 0) gameOver();
          }
        }
      }
    }
  }

  // PROJECTILE handling
  function createProjectile(row, startX, damage) {
    return { row, x: startX, damage, speed: 350, active: true };
  }
  function updateProjectiles(dt) {
    for(let proj of state.projectiles) {
      if(!proj.active) continue;
      proj.x += proj.speed * dt;
      // Check collision with zombies in row
      const hitZombie = state.zombies.find(z => z.row === proj.row && z.x > proj.x - 20 && z.x < proj.x + 20);
      if(hitZombie) {
        hitZombie.hp -= proj.damage;
        if(hitZombie.hp <= 0) {
          state.zombies = state.zombies.filter(zm => zm !== hitZombie);
          zombiesLeftEl.textContent = `Zombies: ${state.zombies.length + state.zombiesToSpawn}`;
        }
        proj.active = false;
      }
      // Remove proj if off screen
      if(proj.x > COLS * CELL_SIZE + 100) proj.active = false;
    }
    // Clean inactive projectiles
    state.projectiles = state.projectiles.filter(p => p.active);
  }

  // SHOOTERS fire timers
  let bananaShootTimer = 0;
  let blueberryShootTimer = 0;
  // WATERMELON water produce timers
  let watermelonTimers = Array(ROWS * COLS).fill(0);

  function updateShooters(dt) {
    bananaShootTimer -= dt*1000;
    blueberryShootTimer -= dt*1000;
    for(let r=0; r<ROWS; r++) {
      for(let c=0; c<COLS; c++) {
        const plant = state.grid[r][c];
        if(!plant) continue;
        if(plant.type === 'banana' && bananaShootTimer <= 0) {
          // shoot only if zombie in row to the right
          if(state.zombies.some(z => z.row === r && z.x > (c+1)*CELL_SIZE)) {
            const startX = c * CELL_SIZE + 40;
            state.projectiles.push(createProjectile(r, startX, PLANTS.banana.damage));
          }
        }
        if(plant.type === 'blueberry' && blueberryShootTimer <= 0) {
          if(state.zombies.some(z => z.row === r && z.x > (c+1)*CELL_SIZE)) {
            const startX = c * CELL_SIZE + 40;
            state.projectiles.push(createProjectile(r, startX, PLANTS.blueberry.damage));
          }
        }
        if(plant.type === 'watermelon') {
          // water produce timer stored on plant itself
          plant.produceTimer = (plant.produceTimer || 0) + dt*1000;
          if(plant.produceTimer >= PLANTS.watermelon.produceMs) {
            plant.produceTimer = 0;
            spawnRain(c * CELL_SIZE + 40, r * CELL_SIZE + 40);
          }
        }
      }
    }
    if(bananaShootTimer <= 0) bananaShootTimer = PLANTS.banana.shootMs;
    if(blueberryShootTimer <= 0) blueberryShootTimer = PLANTS.blueberry.shootMs;
  }

  // LEMON Bomb explode if zombie within 1 grid space
  function updateLemons() {
    for(let r=0; r<ROWS; r++) {
      for(let c=0; c<COLS; c++) {
        const plant = state.grid[r][c];
        if(plant && plant.type === 'lemon') {
          // Check zombies in range
          for(let z of state.zombies) {
            if(z.row === r) {
              const zGridCol = Math.floor(z.x / CELL_SIZE);
              if(Math.abs(zGridCol - c) <= PLANTS.lemon.explodeRange) {
                // Explode! Damage zombies in radius & self destroy
                explodeLemon(r, c);
                break;
              }
            }
          }
        }
      }
    }
  }
  function explodeLemon(r,c) {
    const lemonPlant = state.grid[r][c];
    if(!lemonPlant) return;
    // damage all zombies within explodeRange (1 tile)
    state.zombies = state.zombies.filter(z => {
      if(z.row === r) {
        const zGridCol = Math.floor(z.x / CELL_SIZE);
        if(Math.abs(zGridCol - c) <= PLANTS.lemon.explodeRange) {
          return false; // kill zombie
        }
      }
      return true;
    });
    // destroy lemon plant
    state.grid[r][c] = null;
    renderGrid();
    zombiesLeftEl.textContent = `Zombies: ${state.zombies.length + state.zombiesToSpawn}`;
  }

  // RAIN DROPS falling and tapping
  function spawnRain(x, y) {
    state.rainDrops.push({ x, y: 0, vy: 120 });
  }
  function updateRain(dt) {
    for(let i=state.rainDrops.length-1; i>=0; i--) {
      const drop = state.rainDrops[i];
      drop.y += drop.vy * dt;
      if(drop.y > ROWS * CELL_SIZE) state.rainDrops.splice(i,1);
    }
  }

  // DRAW EVERYTHING
  function draw() {
    // Clear grid text for zombies and projectiles
    [...gridEl.children].forEach(cell => {
      cell.style.position = 'relative';
      cell.style.color = cell.textContent ? 'black' : 'inherit';
      const r = +cell.dataset.row;
      const c = +cell.dataset.col;
      const plant = state.grid[r][c];
      if(!plant) {
        cell.textContent = '';
        cell.style.color = 'inherit';
      } else {
        cell.textContent = PLANTS[plant.type].emoji;
      }
      // update hp bars
      const hpFill = cell.querySelector('.hpfill');
      if(plant) {
        const hpPercent = Math.max(0, (plant.hp / PLANTS[plant.type].hp) * 100);
        hpFill.style.width = hpPercent + '%';
      } else {
        hpFill.style.width = '0%';
      }
      cell.setAttribute('aria-label', plant ? `${plant.type} with health ${plant.hp}` : 'Empty');
    });

    // Draw zombies (absolute positioned divs)
    // Remove old zombies DOM
    let zombieEls = document.querySelectorAll('.zombie');
    zombieEls.forEach(z => z.remove());
    // Draw current zombies
    for(let z of state.zombies) {
      const zombieEl = document.createElement('div');
      zombieEl.className = 'zombie';
      zombieEl.style.position = 'absolute';
      zombieEl.style.top = `${z.row * CELL_SIZE + 10}px`;
      zombieEl.style.left = `${z.x}px`;
      zombieEl.style.width = '44px';
      zombieEl.style.height = '44px';
      zombieEl.style.fontSize = '40px';
      zombieEl.style.userSelect = 'none';
      zombieEl.style.pointerEvents = 'none';
      zombieEl.style.transition = 'left 0.1s linear';
      zombieEl.textContent = 'üßü';
      // zombie hp bar
      const hpBar = document.createElement('div');
      hpBar.className = 'zombie-hpbar';
      hpBar.style.left = zombieEl.style.left;
      hpBar.style.top = `${z.row * CELL_SIZE + 54}px`;
      const hpFill = document.createElement('div');
      hpFill.className = 'zombie-hpfill';
      const hpPercent = Math.max(0, (z.hp / z.maxHp) * 100);
      hpFill.style.width = hpPercent + '%';
      hpBar.appendChild(hpFill);
      zombieEl.appendChild(hpBar);
      gridEl.appendChild(zombieEl);
    }

    // Draw projectiles (yellow or blue balls)
    let projEls = document.querySelectorAll('.projectile');
    projEls.forEach(p => p.remove());
    for(let p of state.projectiles) {
      const pEl = document.createElement('div');
      pEl.className = 'projectile';
      pEl.style.position = 'absolute';
      pEl.style.top = `${p.row * CELL_SIZE + 32}px`;
      pEl.style.left = `${p.x}px`;
      pEl.style.width = '20px';
      pEl.style.height = '20px';
      pEl.style.borderRadius = '50%';
      pEl.style.pointerEvents = 'none';
      if(p.damage === PLANTS.banana.damage) {
        pEl.style.backgroundColor = 'yellow';
      } else if(p.damage === PLANTS.blueberry.damage) {
        pEl.style.backgroundColor = '#3b82f6';
      } else {
        pEl.style.backgroundColor = 'gray';
      }
      gridEl.appendChild(pEl);
    }

    // Draw rain drops üíß
    let rainEls = document.querySelectorAll('.raindrop');
    rainEls.forEach(r => r.remove());
    for(let r of state.rainDrops) {
      const rEl = document.createElement('div');
      rEl.className = 'raindrop';
      rEl.style.position = 'absolute';
      rEl.style.top = `${r.y}px`;
      rEl.style.left = `${r.x}px`;
      rEl.style.fontSize = '32px';
      rEl.style.pointerEvents = 'auto';
      rEl.style.cursor = 'pointer';
      rEl.textContent = 'üíß';
      rEl.addEventListener('click', () => {
        state.coins += RAIN_VALUE;
        coinsEl.textContent = state.coins;
        const idx = state.rainDrops.indexOf(r);
        if(idx !== -1) state.rainDrops.splice(idx, 1);
        rEl.remove();
      });
      gridEl.appendChild(rEl);
    }
  }

  // WAVE MANAGEMENT
  function nextWave() {
    if(state.wave > MAX_WAVE) {
      showMessage('üéâ YOU WON! üéâ');
      saveHighScore();
      state.running = false;
      return;
    }
    showMessage(`Wave ${state.wave} started!`);
    spawnZombies();
  }

  // MESSAGE CENTER
  let messageTimeout;
  function showMessage(msg, duration=2500) {
    centerMsgEl.textContent = msg;
    centerMsgEl.style.display = 'block';
    clearTimeout(messageTimeout);
    messageTimeout = setTimeout(() => {
      centerMsgEl.style.display = 'none';
    }, duration);
  }

  // GAME OVER
  function gameOver() {
    saveHighScore();
    showMessage(`Game Over! You made it to Wave ${state.wave}`);
    state.running = false;
  }

  // GAME LOOP
  let lastTimestamp = 0;
  function gameLoop(timestamp=0) {
    if(!state.running || state.paused) {
      lastTimestamp = timestamp;
      requestAnimationFrame(gameLoop);
      return;
    }
    const dt = (timestamp - lastTimestamp) / 1000;
    lastTimestamp = timestamp;

    // Update
    updateZombies(dt);
    updateProjectiles(dt);
    updateShooters(dt);
    updateLemons();
    updateRain(dt);

    // Draw
    draw();

    // HUD update
    coinsEl.textContent = state.coins;
    healthEl.textContent = state.health;
    zombiesLeftEl.textContent = `Zombies: ${state.zombies.length + state.zombiesToSpawn}`;
    waveEl.textContent = `Wave ${state.wave} / ${MAX_WAVE}`;

    // Wave end detection
    if(state.zombies.length === 0 && state.zombiesToSpawn === 0 && state.running) {
      showMessage(`Wave ${state.wave} completed!`);
      state.wave++;
      setTimeout(nextWave, 2600);
      state.running = false;
    }

    requestAnimationFrame(gameLoop);
  }

  // PAUSE BUTTON
  pauseBtn.addEventListener('click', () => {
    if(!state.running) return;
    state.paused = !state.paused;
    pauseBtn.textContent = state.paused ? 'Resume' : 'Pause';
    pauseBtn.setAttribute('aria-pressed', state.paused);
    if(!state.paused) {
      lastTimestamp = performance.now();
      requestAnimationFrame(gameLoop);
    }
  });

  // NEW GAME BUTTON
  newGameBtn.addEventListener('click', () => {
    resetGame();
    startGame();
  });

  // RESET GAME
  function resetGame() {
    state = {
      wave: 1,
      coins: START_COINS,
      health: START_HEALTH,
      grid: Array.from({ length: ROWS }, () => Array(COLS).fill(null)),
      zombies: [],
      projectiles: [],
      rainDrops: [],
      selectedPlant: 'banana',
      running: false,
      paused: false,
      zombiesToSpawn: 0,
      spawnTimer: 0,
      lastRainTime: 0,
      highScore: state.highScore,
    };
    coinsEl.textContent = state.coins;
    healthEl.textContent = state.health;
    zombiesLeftEl.textContent = `Zombies: 0`;
    waveEl.textContent = `Wave 1 / ${MAX_WAVE}`;
    renderGrid();
    updateToolbarSelection();
    pauseBtn.textContent = 'Pause';
    pauseBtn.setAttribute('aria-pressed', 'false');
    centerMsgEl.style.display = 'none';
  }

  // START GAME
  function startGame() {
    state.running = true;
    nextWave();
    lastTimestamp = performance.now();
    requestAnimationFrame(gameLoop);
  }

  // INITIALIZE
  loadHighScore();
  buildGrid();
  buildToolbar();
  resetGame();

  // Start paused and wait for user
  showMessage('Tap New Game to start!');
})();
</script>

</body>
</html>
