<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>Fruits vs Zombies ‚Äî Emoji Edition</title>
<style>
  :root{
    --bg:#e9fbff;
    --panel:#ffffffcc;
    --accent:#2b9fff;
    --muted:#234;
  }
  html,body{height:100%;margin:0;font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial;}
  body{
    background: linear-gradient(180deg,#e0fbff 0%, #f2fff9 100%);
    display:flex;align-items:center;justify-content:center;padding:10px;
  }
  #wrap{width:100%;max-width:520px;background:var(--panel);border-radius:16px;box-shadow:0 8px 30px rgba(8,20,40,0.12);overflow:hidden}
  header{display:flex;align-items:center;justify-content:space-between;padding:10px 12px;background:transparent}
  .title{font-weight:800;font-size:18px;color:var(--muted);display:flex;gap:8px;align-items:center}
  .hud{display:flex;gap:10px;align-items:center;font-weight:700;color:#072033}
  main{padding:8px}
  .boardWrap{background:transparent;border-radius:12px;padding:10px}
  /* grid is invisible ‚Äî cells have only emoji */
  .grid{display:grid;grid-template-rows:repeat(3,1fr);grid-template-columns:repeat(4,1fr);gap:10px;touch-action:none}
  .cell{display:flex;flex-direction:column;align-items:center;justify-content:center;min-height:72px;user-select:none}
  .emoji{font-size:30px;line-height:1; pointer-events:none}
  .hpbar{width:52px;height:6px;border-radius:6px;background:rgba(0,0,0,0.08);overflow:hidden;margin-top:6px;box-shadow:0 2px 6px rgba(0,0,0,0.06)}
  .hpfill{height:100%;background:linear-gradient(90deg,#4ade80,#16a34a);width:100%}
  .zombHp{width:44px;height:6px;border-radius:6px;background:rgba(0,0,0,0.06);overflow:hidden;margin-top:4px}
  .zombFill{height:100%;background:linear-gradient(90deg,#fb7185,#ef4444);width:100%}
  .toolbar{display:flex;gap:8px;justify-content:center;padding:8px 6px;flex-wrap:wrap}
  .toolBtn{background:transparent;border:none;padding:8px;border-radius:10px;font-size:18px}
  .toolBtn.selected{outline:3px solid rgba(43,159,255,0.18);border-radius:12px}
  .controls{display:flex;gap:8px;justify-content:center;margin-top:6px;padding-bottom:6px}
  .btn{background:var(--accent);color:#fff;padding:8px 12px;border-radius:10px;border:none;font-weight:800}
  .smallBtn{background:#0ea5a5;color:#fff;padding:6px 10px;border-radius:8px;border:none}
  .centerMsg{position:absolute;left:50%;transform:translateX(-50%);top:44%;background:rgba(255,255,255,0.9);padding:10px 14px;border-radius:12px;font-weight:900;display:none;z-index:40}
  footer{padding:8px;display:flex;gap:8px;align-items:center;justify-content:space-between;color:#134}
  .infoSmall{font-size:13px;color:#123}
  /* responsive tweaks */
  @media (max-width:420px){
    .emoji{font-size:28px}
    .hpbar{width:44px}
  }
</style>
</head>
<body>
<div id="wrap">
  <header>
    <div class="title">üçì Fruits vs Zombies (Emoji Edition)</div>
    <div class="hud">
      <div id="waveDisplay">Wave 1 / 15</div>
      <div id="zLeft">Zombies: 0</div>
      <div id="hpDisplay">Health: 5</div>
    </div>
  </header>

  <main>
    <div class="boardWrap" id="boardWrap" style="position:relative;">
      <div class="centerMsg" id="centerMsg"></div>
      <div class="grid" id="grid"></div>
      <!-- Canvas sits above grid for projectiles and rain visuals -->
      <canvas id="overlay" style="position:absolute;inset:10px;pointer-events:none"></canvas>
    </div>

    <div style="display:flex;justify-content:space-between;margin-top:8px;align-items:center">
      <div class="infoSmall">Coins: üíß <span id="coins">15</span></div>
      <div style="display:flex;gap:8px">
        <button id="pauseBtn" class="smallBtn">Pause</button>
        <button id="newBtn" class="smallBtn">New Game</button>
      </div>
    </div>

    <div class="toolbar" id="toolbar" style="margin-top:10px">
      <!-- Buttons will be added by JS -->
    </div>

    <div class="controls">
      <button class="btn" id="placeBtn">Place Selected (tap cell)</button>
    </div>
  </main>

  <footer>
    <div class="infoSmall">Tap falling üíß to collect. Fruits have 4 HP (4 zombie hits).</div>
    <div class="infoSmall">High: <span id="highScore">0</span></div>
  </footer>
</div>

<script>
/* ---------- Configuration ---------- */
const ROWS = 3, COLS = 4;
const MAX_WAVES = 15;
const START_COINS = 15;
const FRUIT_HP = 4; // each fruit dies after 4 zombie hits
const RAIN_INTERVAL_MS = 4000;
const RAIN_VALUE = 1;
const ZOMBIE_BASE_HP = 5; // wave 1
const ZOMBIE_HP_PER_WAVE = 2;
const ZOMBIE_BASE_SPEED = 0.035; // base speed factor, will multiply by canvas width
const ZOMBIE_SPEED_INCREASE = 1.08; // 8% per wave
const SPAWN_BASE = 3; // wave1 zombies count
const SPAWN_INCREMENT = 3; // +3 each wave

/* ---------- Plant definitions ---------- */
const PLANTS = {
  banana:{ key:'banana', emoji:'üçå', cost:10, shootInterval:3500, damage:5, hp:FRUIT_HP},
  lemon: { key:'lemon', emoji:'üçã', cost:8, explodeDamage:25, explodeRange:1, hp:FRUIT_HP},
  watermelon: { key:'watermelon', emoji:'üçâ', cost:5, produceInterval:4000, produce:1, hp:FRUIT_HP},
  blueberry: { key:'blueberry', emoji:'ü´ê', cost:25, shootInterval:2500, damage:10, hp:FRUIT_HP}
};

/* ---------- Game state ---------- */
let state = {
  wave:1,
  coins: START_COINS,
  playerHealth:5,
  grid: Array.from({length:ROWS}, ()=>Array(COLS).fill(null)), // each cell: null or plant object
  zombies: [], // {x, y, row, colTarget?, hp, maxHp, speed, attacking:false, attackTimer}
  projectiles: [], // visual bullets {x,y,tx,ty,speed,damage,color}
  rain: [], // drops {x,y,vy}
  selectedPlant: 'banana',
  running:false,
  paused:false,
  zombiesToSpawn:0,
  spawnTimer:0,
  lastRain:0,
  lastTime:0,
  highScore: 0
};

/* ---------- DOM ---------- */
const gridEl = document.getElementById('grid');
const overlay = document.getElementById('overlay');
const ctx = overlay.getContext('2d');
const coinsEl = document.getElementById('coins');
const hpEl = document.getElementById('hpDisplay');
const zLeftEl = document.getElementById('zLeft');
const waveEl = document.getElementById('waveDisplay');
const toolbar = document.getElementById('toolbar');
const centerMsg = document.getElementById('centerMsg');
const pauseBtn = document.getElementById('pauseBtn');
const newBtn = document.getElementById('newBtn');
const placeBtn = document.getElementById('placeBtn');
const highScoreEl = document.getElementById('highScore');

/* ---------- LocalStorage for high score only ---------- */
const HIGH_KEY = 'fvz_emoji_high';
function loadHigh(){ state.highScore = parseInt(localStorage.getItem(HIGH_KEY)||'0',10) || 0; highScoreEl.textContent = state.highScore; }
function saveHigh(v){ if(v > state.highScore){ state.highScore = v; localStorage.setItem(HIGH_KEY, String(v)); highScoreEl.textContent = state.highScore; } }

/* ---------- Setup grid UI ---------- */
function buildGrid(){
  gridEl.innerHTML = '';
  for(let r=0;r<ROWS;r++){
    for(let c=0;c<COLS;c++){
      const cell = document.createElement('div');
      cell.className = 'cell';
      cell.dataset.r = r; cell.dataset.c = c;
      cell.addEventListener('pointerdown', onCellTap);
      const emoji = document.createElement('div'); emoji.className='emoji'; emoji.textContent = '';
      const hpbar = document.createElement('div'); hpbar.className='hpbar';
      const hpfill = document.createElement('div'); hpfill.className='hpfill'; hpbar.appendChild(hpfill);
      cell.appendChild(emoji);
      cell.appendChild(hpbar);
      gridEl.appendChild(cell);
    }
  }
  resizeOverlay();
  renderGrid();
}

/* ---------- Toolbar ---------- */
function buildToolbar(){
  toolbar.innerHTML = '';
  Object.values(PLANTS).forEach(p=>{
    const btn = document.createElement('button');
    btn.className = 'toolBtn';
    btn.dataset.type = p.key;
    btn.innerHTML = `${p.emoji}<div style="font-size:12px">${p.cost}üíß</div>`;
    btn.addEventListener('click', ()=>{ state.selectedPlant = p.key; updateToolbarSelection(); });
    toolbar.appendChild(btn);
  });
  updateToolbarSelection();
}
function updateToolbarSelection(){
  document.querySelectorAll('.toolBtn').forEach(b=>b.classList.remove('selected'));
  const sel = document.querySelector(`.toolBtn[data-type="${state.selectedPlant}"]`);
  if(sel) sel.classList.add('selected');
}

/* ---------- Render grid plants + hp ---------- */
function renderGrid(){
  const cells = gridEl.children;
  for(let i=0;i<cells.length;i++){
    const r = Math.floor(i/COLS), c = i%COLS;
    const cell = cells[i];
    const emoji = cell.querySelector('.emoji');
    const hpfill = cell.querySelector('.hpfill');
    const slot = state.grid[r][c];
    if(!slot){
      emoji.textContent = '';
      hpfill.style.width = '0%';
    } else {
      emoji.textContent = PLANTS[slot.type].emoji;
      const pct = Math.max(0, (slot.hp / slot.maxHp) * 100);
      hpfill.style.width = pct + '%';
    }
  }
}

/* ---------- Helper: get cell center coords inside overlay ------------ */
function cellCenter(r,c){
  const rect = overlay.getBoundingClientRect();
  const cellW = rect.width / COLS;
  const cellH = rect.height / ROWS;
  const x = (c + 0.5) * cellW;
  const y = (r + 0.5) * cellH;
  return { x, y, w: cellW, h: cellH };
}

/* ---------- Pointer: place or remove ---------- */
function onCellTap(ev){
  if(!state.running || state.paused) return;
  const r = +this.dataset.r, c = +this.dataset.c;
  if(state.grid[r][c]) {
    // remove plant (free removal? We'll allow remove to get nothing back)
    state.grid[r][c] = null;
    renderGrid();
    return;
  }
  // place selected plant if enough coins
  const plantDef = PLANTS[state.selectedPlant];
  if(!plantDef) return;
  if(state.coins < plantDef.cost){
    flashMessage('Not enough üíß');
    return;
  }
  // deduct, place
  state.coins -= plantDef.cost;
  coinsEl.textContent = state.coins;
  state.grid[r][c] = { type: plantDef.key, hp: plantDef.hp, maxHp: plantDef.hp, lastAction: performance.now() };
  renderGrid();
}

/* ---------- Rain handling (tap to collect) ---------- */
overlay.addEventListener('pointerdown', (ev)=>{
  const rect = overlay.getBoundingClientRect();
  const x = ev.clientX - rect.left, y = ev.clientY - rect.top;
  for(let i=state.rain.length-1;i>=0;i--){
    const d = state.rain[i];
    const dx = d.x - x, dy = d.y - y;
    if(Math.sqrt(dx*dx+dy*dy) < 20){
      state.coins += RAIN_VALUE;
      coinsEl.textContent = state.coins;
      state.rain.splice(i,1);
      flashMessage('+1 üíß');
      return;
    }
  }
});

/* ---------- Game loop, spawn, movement ---------- */
function startNewGame(){
  // reset everything but keep high score
  state.wave = 1;
  state.coins = START_COINS;
  state.playerHealth = 5;
  state.grid = Array.from({length:ROWS}, ()=>Array(COLS).fill(null));
  state.zombies = [];
  state.projectiles = [];
  state.rain = [];
  state.zombiesToSpawn = SPAWN_BASE;
  state.spawnTimer = 0;
  state.lastRain = performance.now();
  state.running = true;
  state.paused = false;
  coinsEl.textContent = state.coins;
  hpEl.textContent = 'Health: ' + state.playerHealth;
  waveEl.textContent = `Wave ${state.wave} / ${MAX_WAVES}`;
  zLeftEl.textContent = 'Zombies: ' + state.zombiesToSpawn;
  flashMessage('Wave ' + state.wave + ' starting');
  requestAnimationFrame(loop);
}

/* wave setup */
function startWaveIfNeeded(){
  if(state.zombies.length === 0 && state.zombiesToSpawn === 0){
    // wave completed
    if(state.wave >= MAX_WAVES){
      // win
      saveHigh(state.wave);
      flashMessage('YOU WON!');
      gameEnd(true);
      return;
    }
    flashMessage(`Wave ${state.wave} completed!`);
    // small delay before next wave
    setTimeout(()=>{
      state.wave++;
      // zombiesToSpawn increases by SPAWN_INCREMENT each wave
      state.zombiesToSpawn = SPAWN_BASE + (state.wave-1)*SPAWN_INCREMENT;
      state.spawnTimer = 0;
      waveEl.textContent = `Wave ${state.wave} / ${MAX_WAVES}`;
      // award a few coins
      state.coins += 5;
      coinsEl.textContent = state.coins;
      flashMessage('Wave ' + state.wave + ' start');
    }, 900);
  }
}

/* spawn single zombie */
function spawnOneZombie(){
  const stats = zombieStatsForWave(state.wave);
  const row = Math.floor(Math.random()*ROWS);
  // start x at right side of overlay width
  const rect = overlay.getBoundingClientRect();
  const x = rect.width + 20;
  const y = (row + 0.5) * (rect.height / ROWS);
  const z = {
    x, y, row,
    hp: stats.hp, maxHp: stats.hp,
    speed: stats.speed * rect.width, // px/s
    attacking: false,
    attackTimer: 0,
    targetCell: null
  };
  state.zombies.push(z);
}

/* wave-based stats */
function zombieStatsForWave(w){
  const hp = ZOMBIE_BASE_HP + ZOMBIE_HP_PER_WAVE*(w-1);
  const speedFactor = ZOMBIE_BASE_SPEED * Math.pow(ZOMBIE_SPEED_INCREASE, w-1);
  return { hp, speed: speedFactor };
}

/* main loop */
function loop(ts){
  if(!state.running) return;
  if(state.paused){
    state.lastTime = ts;
    requestAnimationFrame(loop);
    return;
  }
  if(!state.lastTime) state.lastTime = ts;
  const dt = (ts - state.lastTime)/1000; // seconds
  state.lastTime = ts;

  // rain spawn
  if(ts - state.lastRain > RAIN_INTERVAL_MS){
    spawnRainDrop();
    state.lastRain = ts;
  }

  // spawn zombies gradually
  if(state.zombiesToSpawn > 0){
    state.spawnTimer += dt;
    const spawnInterval = Math.max(0.6, 1.6 - (state.wave*0.03)); // a bit faster each wave
    if(state.spawnTimer >= spawnInterval){
      spawnOneZombie();
      state.zombiesToSpawn--;
      state.spawnTimer = 0;
    }
  }

  // update zombies
  const rect = overlay.getBoundingClientRect();
  for(let zi = state.zombies.length-1; zi >=0; zi--){
    const z = state.zombies[zi];
    if(z.attacking){
      // when attacking, use attackTimer to hit every ~0.8s
      z.attackTimer += dt;
      if(z.attackTimer >= 0.8){
        z.attackTimer = 0;
        // apply 1 damage to fruit hp (one hit)
        const cell = state.grid[z.row][z.targetCell];
        if(cell){
          cell.hp -= 1;
          if(cell.hp <= 0){
            state.grid[z.row][z.targetCell] = null;
            z.attacking = false;
            z.targetCell = null;
            // after fruit dies, zombie will resume moving next frame
          }
        } else {
          // fruit missing, resume moving
          z.attacking = false;
          z.targetCell = null;
        }
      }
      continue;
    }

    // not attacking: move left
    z.x -= z.speed * dt;
    // determine which column cell z is facing based on x position relative to overlay width
    const colWidth = rect.width / COLS;
    const col = Math.min(COLS-1, Math.max(0, Math.floor(z.x / colWidth)));
    // check if there's a plant in front in same column and row
    if(col >= 0 && col < COLS){
      const frontPlant = state.grid[z.row][col];
      if(frontPlant){
        // move zombie to just in front of cell center then start attacking
        const ccenter = cellCenter(z.row, col);
        const targetX = ccenter.x + colWidth*0.6; // slightly right of center
        // if close enough, begin attacking
        if(z.x <= targetX + 6){
          z.attacking = true;
          z.targetCell = col;
          z.attackTimer = 0;
        } else {
          // make a small approach step
          // keep moving left normally; no extra logic required
        }
        continue;
      }
    }

    // if reaches left edge -> damage player and remove zombie
    if(z.x < -20){
      state.zombies.splice(zi,1);
      state.playerHealth -= 1;
      hpEl.textContent = 'Health: ' + state.playerHealth;
      if(state.playerHealth <= 0){
        // game over
        saveHigh(state.wave);
        gameEnd(false);
        return;
      }
    }
  }

  // projectiles movement (simple straight to target)
  for(let pi = state.projectiles.length-1; pi>=0; pi--){
    const p = state.projectiles[pi];
    const dx = p.tx - p.x, dy = p.ty - p.y;
    const dist = Math.hypot(dx,dy);
    const step = p.speed * dt;
    if(dist <= step || dist === 0){
      // hit target if target still alive
      if(p.target && p.target.hp > 0){
        p.target.hp -= p.damage;
      }
      state.projectiles.splice(pi,1);
    } else {
      p.x += dx/dist * step;
      p.y += dy/dist * step;
    }
  }

  // plant automatic actions
  const now = performance.now();
  for(let r=0;r<ROWS;r++){
    for(let c=0;c<COLS;c++){
      const slot = state.grid[r][c];
      if(!slot) continue;
      const pd = PLANTS[slot.type];
      if(pd.shootInterval){
        if(!slot._lastShoot) slot._lastShoot = now;
        if(now - slot._lastShoot >= pd.shootInterval){
          // find a target zombie in same row first
          let target = null;
          for(const z of state.zombies){
            if(z.row === r && z.hp > 0){
              target = z; break;
            }
          }
          if(!target && state.zombies.length) target = state.zombies[Math.floor(Math.random()*state.zombies.length)];
          if(target){
            const cc = cellCenter(r,c);
            state.projectiles.push({ x: cc.x, y: cc.y, tx: target.x, ty: target.y, speed: 320, damage: pd.damage, target });
          }
          slot._lastShoot = now;
        }
      }
      if(pd.produceInterval){
        if(!slot._lastProduce) slot._lastProduce = now;
        if(now - slot._lastProduce >= pd.produceInterval){
          state.coins += pd.produce;
          coinsEl.textContent = state.coins;
          slot._lastProduce = now;
        }
      }
      // lemon's explode is checked elsewhere (proximity)
    }
  }

  // lemons: explode if any zombie within 1-grid cell (Chebyshev distance)
  for(let r=0;r<ROWS;r++){
    for(let c=0;c<COLS;c++){
      const slot = state.grid[r][c];
      if(!slot || slot.type !== 'lemon') continue;
      // compute fruit center
      const cc = cellCenter(r,c);
      // check zombies within ~one cell radius
      const cellDiag = Math.max(rect.width/COLS, rect.height/ROWS) * 1.1;
      let exploded = false;
      for(let zi = state.zombies.length-1; zi>=0; zi--){
        const z = state.zombies[zi];
        const dx = z.x - cc.x, dy = z.y - cc.y;
        if(Math.hypot(dx,dy) <= cellDiag){
          // explode: damage all zombies near
          for(const z2 of state.zombies){
            const dx2 = z2.x - cc.x, dy2 = z2.y - cc.y;
            if(Math.hypot(dx2,dy2) <= cellDiag){
              z2.hp -= PLANTS.lemon.explodeDamage;
            }
          }
          // remove lemon
          state.grid[r][c] = null;
          exploded = true;
          break;
        }
      }
      if(exploded) renderGrid();
    }
  }

  // remove dead zombies and reward coin maybe (we won't reward to keep simple)
  for(let i=state.zombies.length-1;i>=0;i--){
    if(state.zombies[i].hp <= 0) state.zombies.splice(i,1);
  }

  // keep HUD updated
  zLeftEl.textContent = 'Zombies: ' + (state.zombies.length + state.zombiesToSpawn);
  coinsEl.textContent = state.coins;
  waveEl.textContent = `Wave ${state.wave} / ${MAX_WAVES}`;

  // render visuals
  drawAll();

  // check if wave cleared to start next
  if(state.zombies.length === 0 && state.zombiesToSpawn === 0){
    // small delay handled by startWaveIfNeeded
    startWaveIfNeeded();
  }

  requestAnimationFrame(loop);
}

/* ---------- Draw everything on overlay canvas ---------- */
function drawAll(){
  resizeOverlay();
  ctx.clearRect(0,0,overlay.width,overlay.height);
  const rect = overlay.getBoundingClientRect();

  // draw rain drops
  for(const d of state.rain){
    ctx.beginPath();
    ctx.ellipse(d.x, d.y, 9, 12, 0, 0, Math.PI*2);
    ctx.fillStyle = '#6ec6ff';
    ctx.fill();
    ctx.font = '14px serif';
    ctx.fillText('üíß', d.x-6, d.y+4);
  }

  // draw projectiles
  for(const p of state.projectiles){
    ctx.beginPath();
    ctx.fillStyle = p.damage >= 10 ? '#3b82f6' : '#facc15';
    ctx.arc(p.x, p.y, 6, 0, Math.PI*2);
    ctx.fill();
  }

  // draw zombies as emoji + health bar under them
  ctx.font = Math.max(18, overlay.width/18) + 'px serif';
  ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
  for(const z of state.zombies){
    ctx.fillText('üßü', z.x, z.y+2);
    // hp bar
    const bw = Math.min(44, overlay.width/10);
    const bx = z.x - bw/2;
    const by = z.y + 28;
    ctx.fillStyle = 'rgba(0,0,0,0.08)'; ctx.fillRect(bx, by, bw, 6);
    ctx.fillStyle = 'linear-gradient(#f00,#900)'; // fallback
    ctx.fillStyle = '#ef4444';
    const hpw = Math.max(0, (z.hp / z.maxHp) * bw);
    ctx.fillRect(bx, by, hpw, 6);
    ctx.strokeStyle = 'rgba(0,0,0,0.12)'; ctx.strokeRect(bx, by, bw, 6);
  }

  // optionally draw small indicators for plant hp above emoji in grid (grid UI does this already)
}

/* ---------- Rain spawn / update ---------- */
function spawnRainDrop(){
  const rect = overlay.getBoundingClientRect();
  const x = 10 + Math.random() * (rect.width - 20);
  state.rain.push({ x, y: -8, vy: 80 + Math.random()*40 });
}
function updateRain(dt){
  for(let i=state.rain.length-1;i>=0;i--){
    const d = state.rain[i];
    d.y += d.vy * dt;
    if(d.y > overlay.height + 30) state.rain.splice(i,1);
  }
}

/* ---------- Utility: resize overlay canvas to container ---------- */
function resizeOverlay(){
  const rect = overlay.getBoundingClientRect();
  // get computed rect via parent
  const parentRect = document.getElementById('boardWrap').getBoundingClientRect();
  // overlay is absolute inset 10px; compute width/height
  const width = parentRect.width - 20;
  const height = Math.max(180, width * 3/4 - 10);
  overlay.style.width = width + 'px';
  overlay.style.height = height + 'px';
  overlay.width = width;
  overlay.height = height;
}

/* ---------- Helper: cell center returned in overlay coords ---------- */
function cellCenter(row, col){
  const w = overlay.width / COLS;
  const h = overlay.height / ROWS;
  const x = (col + 0.5) * w;
  const y = (row + 0.5) * h;
  return { x, y, w, h };
}

/* ---------- Start/End ---------- */
function gameEnd(won){
  state.running = false;
  if(won){
    centerMsgInner('YOU WON! üéâ', true);
  } else {
    centerMsgInner('Game Over', true);
  }
  saveHigh(state.wave);
  setTimeout(()=>centerMsg.style.display='none', 3000);
}

/* ---------- Small UI helpers ---------- */
let centerTimer = null;
function centerMsgInner(txt, sticky=false){
  centerMsg.style.display = 'block';
  centerMsg.textContent = txt;
  if(!sticky) {
    clearTimeout(centerTimer);
    centerTimer = setTimeout(()=> centerMsg.style.display = 'none', 900);
  }
}
function flashMessage(txt){
  centerMsgInner(txt, false);
}

/* ---------- Periodic updates for rain, plant timers, speed-on-resize ---------- */
let lastTick = performance.now();
setInterval(()=>{
  if(!state.running || state.paused) { lastTick = performance.now(); return; }
  const now = performance.now();
  const dt = (now - lastTick) / 1000;
  lastTick = now;
  // update rain positions
  updateRain(dt);
  // update plant firing / produce actions handled in main loop via timestamps
}, 60);

/* ---------- Bind buttons ---------- */
pauseBtn.addEventListener('click', ()=>{
  state.paused = !state.paused;
  pauseBtn.textContent = state.paused ? 'Resume' : 'Pause';
});
newBtn.addEventListener('click', ()=> {
  // always start fresh (no continue)
  startNewGame();
});
placeBtn.addEventListener('click', ()=> flashMessage('Tap an empty cell to place selected fruit'));

/* ---------- Initialization ---------- */
function init(){
  loadHigh();
  buildToolbar();
  buildGrid();
  resizeOverlay();
  // wire up resize
  window.addEventListener('resize', ()=>{ resizeOverlay(); });
  // start with an immediate fresh game
  startNewGame();
  // main animation frame loop also handles spawn and physics ‚Äî we need to keep calling it
  state.lastTime = 0;
  (function frame(now){
    if(state.running && !state.paused){
      // advance rain, spawn timing and plant timers are within main loop; call loop manually here
      // We'll call loop by requesting an animation frame for centralization
    }
    requestAnimationFrame(frame);
  })();
  // Launch main loop via requestAnimationFrame wrapper
  requestAnimationFrame((t)=>{ state.lastTime = t; loop(t); });
}
init();

/* ---------- Clean-up: periodically update zombies speed on resize ---------- */
new ResizeObserver(()=> {
  // when overlay width changes, update zombie px/s speeds based on new width
  for(const z of state.zombies){
    const stats = zombieStatsForWave(state.wave);
    z.speed = stats.speed * overlay.width;
  }
}).observe(overlay);

/* ---------- Helper: advance spawn count when starting (initial wave config) ---------- */
(function initWaveSpawn(){
  state.zombiesToSpawn = SPAWN_BASE + (state.wave-1)*SPAWN_INCREMENT;
})();

/* ---------- Save high score when window unload (just in case) ---------- */
window.addEventListener('beforeunload', ()=>{ saveHigh(state.wave); });

</script>
</body>
</html>
