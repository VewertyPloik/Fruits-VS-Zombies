<!DOCTYPE html>
<html lang="en" >
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Fruits vs Zombies - Mobile Ready</title>
  <style>
    :root {
      --green: #3a8d3a;
      --darkgreen: #2a6b2a;
      --lightgreen: #a0d080;
      --accent: #2b9fff;
      --red: #ef4444;
      --yellow: #facc15;
      --blue: #3b82f6;
      --font: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
    }
    * {
      box-sizing: border-box;
    }
    body {
      margin: 0; 
      min-height: 100vh;
      font-family: var(--font);
      background: linear-gradient(to bottom, #e6fbff 0%, #f2fff9 100%);
      display: flex;
      justify-content: center;
      padding: 10px 0;
      user-select: none;
      -webkit-tap-highlight-color: transparent;
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
      overscroll-behavior: contain;
    }
    #app {
      background: #ffffffee;
      border-radius: 14px;
      width: 100%;
      max-width: 480px;
      box-shadow: 0 12px 40px rgba(6,30,60,0.12);
      display: flex;
      flex-direction: column;
      height: 100vh;
      max-height: 760px;
      touch-action: manipulation;
      -webkit-tap-highlight-color: transparent;
    }
    header {
      padding: 10px 12px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      background: var(--lightgreen);
      border-bottom: 2px solid var(--darkgreen);
      font-weight: 700;
      color: var(--darkgreen);
      font-size: 14px;
      user-select:none;
    }
    header > div {
      display: flex;
      gap: 15px;
      align-items: center;
    }
    #board {
      position: relative;
      flex: 1;
      background:
        linear-gradient(var(--darkgreen) 2px, transparent 2px),
        linear-gradient(90deg, var(--darkgreen) 2px, transparent 2px);
      background-size: calc(100% / 4) calc(100% / 3);
      user-select:none;
      border-radius: 10px;
      margin: 10px 12px 6px;
      -webkit-tap-highlight-color: transparent;
    }
    #grid {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      grid-template-rows: repeat(3, 1fr);
      width: 100%;
      height: 100%;
      position: relative;
      -webkit-tap-highlight-color: transparent;
    }
    .cell {
      position: relative;
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 44px;
      user-select:none;
      cursor: pointer;
      transition: background-color 0.15s ease;
      touch-action: manipulation;
      -webkit-tap-highlight-color: transparent;
    }
    .cell:active {
      background: rgba(170, 230, 170, 0.3);
    }
    .hpbar {
      position: absolute;
      bottom: 4px;
      left: 12px;
      right: 12px;
      height: 6px;
      border-radius: 9999px;
      background: rgba(0,0,0,0.1);
      overflow: hidden;
    }
    .hpfill {
      height: 100%;
      background: linear-gradient(90deg, #34d399, #059669);
      width: 100%;
      transition: width 0.3s ease;
    }
    .zombie-hpbar {
      position: absolute;
      bottom: 12px;
      width: 44px;
      height: 6px;
      border-radius: 9999px;
      background: rgba(0,0,0,0.1);
      overflow: hidden;
    }
    .zombie-hpfill {
      height: 100%;
      background: linear-gradient(90deg, #fb7185, #ef4444);
      width: 100%;
      transition: width 0.3s ease;
    }
    #toolbar {
      display: flex;
      gap: 10px;
      padding: 0 12px 12px;
      justify-content: center;
      user-select:none;
    }
    .toolBtn {
      font-size: 34px;
      background: transparent;
      border: 2.8px solid transparent;
      border-radius: 12px;
      padding: 8px 10px 6px;
      cursor: pointer;
      user-select:none;
      display: flex;
      flex-direction: column;
      align-items: center;
      color: var(--darkgreen);
      font-weight: 700;
      width: 70px;
      touch-action: manipulation;
      -webkit-tap-highlight-color: transparent;
      position: relative;
    }
    .toolBtn span {
      font-size: 14px;
      margin-top: 4px;
      user-select:none;
      pointer-events:none;
      font-weight: 600;
    }
    .toolBtn .price {
      font-size: 13px;
      color: var(--blue);
      margin-top: 2px;
      font-weight: 700;
      user-select:none;
      pointer-events:none;
    }
    .toolBtn.selected {
      border-color: var(--accent);
      color: var(--accent);
      background: #def9ffaa;
    }
    #infoBar {
      display: flex;
      justify-content: center;
      padding: 0 12px 8px;
      font-weight: 600;
      font-size: 15px;
      color: var(--darkgreen);
      user-select:none;
      text-align: center;
    }
    #controls {
      display: flex;
      justify-content: center;
      gap: 14px;
      padding-bottom: 14px;
      user-select:none;
    }
    button.btn {
      background: var(--accent);
      color: white;
      font-weight: 700;
      border: none;
      border-radius: 12px;
      padding: 10px 24px;
      font-size: 18px;
      cursor: pointer;
      user-select:none;
      transition: background-color 0.2s ease;
      min-width: 110px;
      touch-action: manipulation;
      -webkit-tap-highlight-color: transparent;
    }
    button.btn:hover:not(:disabled) {
      background: #0071d1;
    }
    button.btn:disabled {
      opacity: 0.5;
      cursor: default;
    }
    #centerMsg {
      position: absolute;
      left: 50%;
      top: 40%;
      transform: translateX(-50%);
      background: rgba(255 255 255 / 0.95);
      padding: 18px 28px;
      border-radius: 18px;
      font-weight: 800;
      font-size: 20px;
      color: var(--darkgreen);
      pointer-events:none;
      user-select:none;
      display: none;
      z-index: 50;
      box-shadow: 0 6px 22px rgba(8,20,40,0.12);
      text-align: center;
      max-width: 90vw;
      word-break: break-word;
    }
    /* Responsive */
    @media (max-width: 420px) {
      #app { max-height: 100vh; }
      .cell {
        font-size: 38px;
      }
      .toolBtn {
        width: 60px;
        font-size: 28px;
      }
      .toolBtn span {
        font-size: 13px;
      }
      .toolBtn .price {
        font-size: 11px;
      }
      button.btn {
        font-size: 16px;
        padding: 10px 18px;
        min-width: 90px;
      }
    }
  </style>
</head>
<body>
  <div id="app" role="main" aria-label="Fruits vs Zombies game">
    <header aria-live="polite">
      <div>
        <span id="waveDisplay">Wave 1 / 15</span>
        <span id="zombiesLeft">Zombies: 0</span>
      </div>
      <div>
        <span>üíß <span id="coinsDisplay">15</span></span>
        <span>‚ù§Ô∏è <span id="healthDisplay">5</span></span>
      </div>
    </header>

    <div id="board" aria-label="Game board">
      <div id="grid" aria-label="Game grid"></div>
      <div id="centerMsg" aria-live="assertive"></div>
    </div>

    <div id="toolbar" aria-label="Select fruit to place"></div>

    <div id="infoBar" aria-live="polite">
      Tap a fruit below then tap a green grid cell to place it (costs üíß coins). Collect falling üíß drops to earn coins. Fruits have 4 HP. Zombies eat fruits to reach your health.
    </div>

    <div id="controls">
      <button id="newGameBtn" class="btn">New Game</button>
    </div>
  </div>

<script>
(() => {
  // CONFIG
  const ROWS = 3, COLS = 4, MAX_WAVE = 15;
  const START_COINS = 15, START_HEALTH = 5;
  const FRUIT_HP = 4;
  const RAIN_INTERVAL_MS = 4000;
  const RAIN_VALUE = 1;
  const ZOMBIE_BASE_HP = 5;
  const ZOMBIE_HP_PER_WAVE = 2;
  const ZOMBIE_BASE_SPEED = 30; // px per second, wave 1 base speed
  const ZOMBIE_SPEED_MULT_PER_WAVE = 1.08;
  const SPAWN_BASE = 3;
  const SPAWN_INC = 3;
  const ZOMBIE_BITE_INTERVAL = 0.8; // seconds per bite
  const CELL_SIZE = 100; // approx for calculations

  // PLANTS DATA
  const PLANTS = {
    banana: { key: 'banana', emoji: 'üçå', cost: 10, shootMs: 3500, damage: 5, hp: FRUIT_HP },
    lemon: { key: 'lemon', emoji: 'üçã', cost: 8, explodeDmg: 25, explodeRange: 1, hp: FRUIT_HP },
    watermelon: { key: 'watermelon', emoji: 'üçâ', cost: 5, produceMs: 4000, produce: 1, hp: FRUIT_HP },
    blueberry: { key: 'blueberry', emoji: 'ü´ê', cost: 25, shootMs: 2500, damage: 10, hp: FRUIT_HP },
  };

  // STATE
  let state = {
    wave: 1,
    coins: START_COINS,
    health: START_HEALTH,
    grid: Array.from({ length: ROWS }, () => Array(COLS).fill(null)),
    zombies: [], // {x, row, hp, maxHp, speed, attacking, attackTimer, targetCol}
    projectiles: [], // {x, y, row, speed, damage, active}
    rainDrops: [], // {x, y, vy}
    selectedPlant: 'banana',
    running: false,
    zombiesToSpawn: 0,
    spawnTimer: 0,
    lastRainTime: 0,
    highScore: 0,
  };

  // DOM elements
  const gridEl = document.getElementById('grid');
  const coinsEl = document.getElementById('coinsDisplay');
  const healthEl = document.getElementById('healthDisplay');
  const zombiesLeftEl = document.getElementById('zombiesLeft');
  const waveEl = document.getElementById('waveDisplay');
  const toolbarEl = document.getElementById('toolbar');
  const centerMsgEl = document.getElementById('centerMsg');
  const newGameBtn = document.getElementById('newGameBtn');

  // LOCAL STORAGE KEY
  const HIGH_SCORE_KEY = 'fruitsVsZombiesHighScore';

  // INIT
  function loadHighScore() {
    const hs = parseInt(localStorage.getItem(HIGH_SCORE_KEY) || '0', 10);
    state.highScore = isNaN(hs) ? 0 : hs;
  }
  function saveHighScore() {
    if(state.wave > state.highScore) {
      state.highScore = state.wave;
      localStorage.setItem(HIGH_SCORE_KEY, state.highScore);
    }
  }

  // BUILD GRID DOM with cells & hp bars
  function buildGrid() {
    gridEl.innerHTML = '';
    for(let r = 0; r < ROWS; r++) {
      for(let c = 0; c < COLS; c++) {
        const cell = document.createElement('div');
        cell.className = 'cell';
        cell.dataset.row = r;
        cell.dataset.col = c;
        // Add HP bar container
        const hpbar = document.createElement('div');
        hpbar.className = 'hpbar';
        const hpfill = document.createElement('div');
        hpfill.className = 'hpfill';
        hpbar.appendChild(hpfill);
        cell.appendChild(hpbar);
        // Place plant on tap
        cell.addEventListener('click', () => placePlant(r,c));
        gridEl.appendChild(cell);
      }
    }
  }

  // BUILD TOOLBAR with fruit buttons and prices
  function buildToolbar() {
    toolbarEl.innerHTML = '';
    Object.values(PLANTS).forEach(plant => {
      const btn = document.createElement('button');
      btn.className = 'toolBtn';
      btn.textContent = plant.emoji;
      btn.title = `${plant.emoji} - Cost: ${plant.cost} üíß`;
      const label = document.createElement('span');
      label.textContent = plant.key.charAt(0).toUpperCase() + plant.key.slice(1);
      const price = document.createElement('span');
      price.className = 'price';
      price.textContent = `üíß${plant.cost}`;
      btn.appendChild(label);
      btn.appendChild(price);
      btn.addEventListener('click', () => {
        state.selectedPlant = plant.key;
        updateToolbarSelection();
      });
      toolbarEl.appendChild(btn);
    });
    updateToolbarSelection();
  }
  function updateToolbarSelection() {
    [...toolbarEl.children].forEach(btn => {
      const plant = Object.values(PLANTS).find(p => btn.textContent.includes(p.emoji));
      if(plant && plant.key === state.selectedPlant) btn.classList.add('selected');
      else btn.classList.remove('selected');
    });
  }

  // PLACE plant on grid cell if empty & affordable
  function placePlant(r, c) {
    if(!state.running) return;
    if(state.grid[r][c]) return; // occupied
    const plant = PLANTS[state.selectedPlant];
    if(state.coins < plant.cost) return;
    state.grid[r][c] = { type: plant.key, hp: plant.hp, produceTimer: 0 };
    state.coins -= plant.cost;
    coinsEl.textContent = state.coins;
    renderGrid();
  }

  // SPAWN ZOMBIES for wave
  function spawnZombies() {
    state.zombiesToSpawn = SPAWN_BASE + SPAWN_INC * (state.wave - 1);
    state.spawnTimer = 0;
  }

  // CREATE a zombie object on row
  function createZombie(row) {
    const maxHp = ZOMBIE_BASE_HP + (ZOMBIE_HP_PER_WAVE * (state.wave - 1));
    const speed = ZOMBIE_BASE_SPEED * Math.pow(ZOMBIE_SPEED_MULT_PER_WAVE, state.wave - 1);
    return {
      x: COLS * CELL_SIZE + 40,
      row,
      hp: maxHp,
      maxHp,
      speed,
      attacking: false,
      attackTimer: 0,
      targetCol: COLS - 1,
    };
  }

  // UPDATE zombies movement and attacks
  function updateZombies(dt) {
    if(state.zombiesToSpawn > 0) {
      state.spawnTimer -= dt;
      if(state.spawnTimer <= 0) {
        // spawn zombie at random row, no multiple spawn on same tick
        const r = Math.floor(Math.random() * ROWS);
        state.zombies.push(createZombie(r));
        state.zombiesToSpawn--;
        state.spawnTimer = 2; // spawn every 2 seconds
      }
    }
    // Update zombies
    for(let i = state.zombies.length -1; i >= 0; i--) {
      let z = state.zombies[i];
      if(z.attacking) {
        z.attackTimer -= dt;
        if(z.attackTimer <= 0) {
          let plant = state.grid[z.row][z.targetCol];
          if(plant) {
            plant.hp--;
            if(plant.hp <= 0) {
              state.grid[z.row][z.targetCol] = null;
              renderGrid();
              z.attacking = false;
            }
          }
          z.attackTimer = ZOMBIE_BITE_INTERVAL;
        }
      } else {
        // Move left unless hitting plant
        if(state.grid[z.row][z.targetCol]) {
          z.attacking = true;
          z.attackTimer = 0;
        } else {
          z.x -= z.speed * dt;
          if(z.x < -40) {
            // Zombie passed player, lose health
            state.health--;
            healthEl.textContent = state.health;
            // Remove zombie
            state.zombies.splice(i,1);
            if(state.health <= 0) {
              gameOver();
              return;
            }
          }
        }
      }
    }
  }

  // CREATE projectiles (banana yellow balls, blueberry blue balls)
  function createProjectile(row, startX, damage, color) {
    return { row, x: startX, damage, color, speed: 350, active: true };
  }
  // UPDATE projectiles
  function updateProjectiles(dt) {
    for(let i = state.projectiles.length - 1; i >= 0; i--) {
      const proj = state.projectiles[i];
      if(!proj.active) continue;
      proj.x += proj.speed * dt;
      // Check collision with zombies in same row
      const hitZombie = state.zombies.find(z => z.row === proj.row && z.x > proj.x - 20 && z.x < proj.x + 20);
      if(hitZombie) {
        hitZombie.hp -= proj.damage;
        if(hitZombie.hp <= 0) {
          // Remove zombie
          const index = state.zombies.indexOf(hitZombie);
          if(index > -1) state.zombies.splice(index, 1);
          zombiesLeftEl.textContent = `Zombies: ${state.zombies.length + state.zombiesToSpawn}`;
        }
        proj.active = false;
      }
      // Remove if off screen
      if(proj.x > COLS * CELL_SIZE + 100) proj.active = false;
    }
    // Remove inactive projectiles
    state.projectiles = state.projectiles.filter(p => p.active);
  }

  // SHOOTERS timers
  let bananaShootTimer = 0;
  let blueberryShootTimer = 0;

  function updateShooters(dt) {
    bananaShootTimer -= dt * 1000;
    blueberryShootTimer -= dt * 1000;
    for(let r=0; r < ROWS; r++) {
      for(let c=0; c < COLS; c++) {
        const plant = state.grid[r][c];
        if(!plant) continue;
        if(plant.type === 'banana' && bananaShootTimer <= 0) {
          // shoot if zombie to right in row
          if(state.zombies.some(z => z.row === r && z.x > (c+1)*CELL_SIZE)) {
            const startX = c * CELL_SIZE + 40;
            state.projectiles.push(createProjectile(r, startX, PLANTS.banana.damage, 'yellow'));
          }
        }
        if(plant.type === 'blueberry' && blueberryShootTimer <= 0) {
          if(state.zombies.some(z => z.row === r && z.x > (c+1)*CELL_SIZE)) {
            const startX = c * CELL_SIZE + 40;
            state.projectiles.push(createProjectile(r, startX, PLANTS.blueberry.damage, '#3b82f6'));
          }
        }
        if(plant.type === 'watermelon') {
          plant.produceTimer = (plant.produceTimer || 0) + dt*1000;
          if(plant.produceTimer >= PLANTS.watermelon.produceMs) {
            plant.produceTimer = 0;
            spawnRain(c * CELL_SIZE + 40, r * CELL_SIZE + 40);
          }
        }
      }
    }
    if(bananaShootTimer <= 0) bananaShootTimer = PLANTS.banana.shootMs;
    if(blueberryShootTimer <= 0) blueberryShootTimer = PLANTS.blueberry.shootMs;
  }

  // LEMON explode if zombie close
  function updateLemons() {
    for(let r=0; r<ROWS; r++) {
      for(let c=0; c<COLS; c++) {
        const plant = state.grid[r][c];
        if(plant && plant.type === 'lemon') {
          for(let z of state.zombies) {
            if(z.row === r) {
              const zGridCol = Math.floor(z.x / CELL_SIZE);
              if(Math.abs(zGridCol - c) <= PLANTS.lemon.explodeRange) {
                explodeLemon(r,c);
                break;
              }
            }
          }
        }
      }
    }
  }
  function explodeLemon(r,c) {
    if(!state.grid[r][c]) return;
    // Remove zombies in range
    state.zombies = state.zombies.filter(z => {
      if(z.row === r) {
        const zGridCol = Math.floor(z.x / CELL_SIZE);
        if(Math.abs(zGridCol - c) <= PLANTS.lemon.explodeRange) return false;
      }
      return true;
    });
    // Remove lemon plant
    state.grid[r][c] = null;
    renderGrid();
    zombiesLeftEl.textContent = `Zombies: ${state.zombies.length + state.zombiesToSpawn}`;
  }

  // RAIN drops falling and tapping for coins
  function spawnRain(x, y) {
    state.rainDrops.push({ x, y: 0, vy: 120 });
  }
  function updateRain(dt) {
    for(let i=state.rainDrops.length-1; i>=0; i--) {
      let drop = state.rainDrops[i];
      drop.y += drop.vy * dt;
      if(drop.y > ROWS * CELL_SIZE) state.rainDrops.splice(i,1);
    }
  }

  // DRAW EVERYTHING
  function draw() {
    // Clear & draw grid cells fruits & HP
    [...gridEl.children].forEach(cell => {
      const r = +cell.dataset.row;
      const c = +cell.dataset.col;
      const plant = state.grid[r][c];
      const hpFill = cell.querySelector('.hpfill');
      if(!plant) {
        cell.textContent = '';
        hpFill.style.width = '0%';
        cell.style.color = 'inherit';
      } else {
        cell.textContent = PLANTS[plant.type].emoji;
        const hpPercent = Math.max(0, (plant.hp / PLANTS[plant.type].hp) * 100);
        hpFill.style.width = hpPercent + '%';
        cell.style.color = 'black';
      }
    });

    // Draw zombies
    document.querySelectorAll('.zombie').forEach(z => z.remove());
    for(let z of state.zombies) {
      const zombieEl = document.createElement('div');
      zombieEl.className = 'zombie';
      zombieEl.style.position = 'absolute';
      zombieEl.style.top = (z.row * CELL_SIZE + 12) + 'px';
      zombieEl.style.left = z.x + 'px';
      zombieEl.style.width = '44px';
      zombieEl.style.height = '44px';
      zombieEl.style.fontSize = '40px';
      zombieEl.style.userSelect = 'none';
      zombieEl.style.pointerEvents = 'none';
      zombieEl.style.transition = 'left 0.1s linear';
      zombieEl.textContent = 'üßü';
      // HP bar
      const hpBar = document.createElement('div');
      hpBar.className = 'zombie-hpbar';
      hpBar.style.position = 'absolute';
      hpBar.style.top = (z.row * CELL_SIZE + 56) + 'px';
      hpBar.style.left = z.x + 'px';
      hpBar.style.width = '44px';
      hpBar.style.height = '6px';
      const hpFill = document.createElement('div');
      hpFill.className = 'zombie-hpfill';
      const hpPercent = Math.max(0, (z.hp / z.maxHp) * 100);
      hpFill.style.width = hpPercent + '%';
      hpBar.appendChild(hpFill);
      document.getElementById('board').appendChild(hpBar);
      document.getElementById('board').appendChild(zombieEl);
    }

    // Draw projectiles
    document.querySelectorAll('.projectile').forEach(p => p.remove());
    for(let p of state.projectiles) {
      const pEl = document.createElement('div');
      pEl.className = 'projectile';
      pEl.style.position = 'absolute';
      pEl.style.top = (p.row * CELL_SIZE + 60) + 'px';
      pEl.style.left = p.x + 'px';
      pEl.style.width = '20px';
      pEl.style.height = '20px';
      pEl.style.borderRadius = '50%';
      pEl.style.pointerEvents = 'none';
      pEl.style.backgroundColor = p.color;
      document.getElementById('board').appendChild(pEl);
    }

    // Draw rain drops
    document.querySelectorAll('.raindrop').forEach(r => r.remove());
    for(let r of state.rainDrops) {
      const rEl = document.createElement('div');
      rEl.className = 'raindrop';
      rEl.style.position = 'absolute';
      rEl.style.top = r.y + 'px';
      rEl.style.left = r.x + 'px';
      rEl.style.fontSize = '32px';
      rEl.style.cursor = 'pointer';
      rEl.textContent = 'üíß';
      rEl.addEventListener('click', () => {
        state.coins += RAIN_VALUE;
        coinsEl.textContent = state.coins;
        const idx = state.rainDrops.indexOf(r);
        if(idx !== -1) state.rainDrops.splice(idx, 1);
        rEl.remove();
      });
      document.getElementById('board').appendChild(rEl);
    }
  }

  // WAVE MANAGEMENT
  function nextWave() {
    if(state.wave > MAX_WAVE) {
      showMessage('üéâ YOU WON! üéâ');
      saveHighScore();
      state.running = false;
      return;
    }
    showMessage(`Wave ${state.wave} started!`);
    spawnZombies();
  }

  // MESSAGE CENTER
  let messageTimeout;
  function showMessage(msg, duration=2000) {
    centerMsgEl.textContent = msg;
    centerMsgEl.style.display = 'block';
    clearTimeout(messageTimeout);
    messageTimeout = setTimeout(() => {
      centerMsgEl.style.display = 'none';
    }, duration);
  }

  // GAME OVER
  function gameOver() {
    saveHighScore();
    showMessage(`Game Over! You made it to Wave ${state.wave}`);
    state.running = false;
  }

  // GAME LOOP
  let lastTimestamp = 0;
  function gameLoop(timestamp=0) {
    if(!state.running) {
      lastTimestamp = timestamp;
      requestAnimationFrame(gameLoop);
      return;
    }
    const dt = (timestamp - lastTimestamp) / 1000;
    lastTimestamp = timestamp;

    updateZombies(dt);
    updateProjectiles(dt);
    updateShooters(dt);
    updateLemons();
    updateRain(dt);

    draw();

    coinsEl.textContent = state.coins;
    healthEl.textContent = state.health;
    zombiesLeftEl.textContent = `Zombies: ${state.zombies.length + state.zombiesToSpawn}`;
    waveEl.textContent = `Wave ${state.wave} / ${MAX_WAVE}`;

    // Detect wave completion
    if(state.zombies.length === 0 && state.zombiesToSpawn === 0 && state.running) {
      showMessage(`Wave ${state.wave} completed!`);
      state.wave++;
      state.running = false;
      setTimeout(() => {
        if(state.health > 0) {
          state.running = true;
          nextWave();
        }
      }, 2300);
    }

    requestAnimationFrame(gameLoop);
  }

  // NEW GAME
  newGameBtn.addEventListener('click', () => {
    resetGame();
    startGame();
  });

  function resetGame() {
    state = {
      ...state,
      wave: 1,
      coins: START_COINS,
      health: START_HEALTH,
      grid: Array.from({ length: ROWS }, () => Array(COLS).fill(null)),
      zombies: [],
      projectiles: [],
      rainDrops: [],
      selectedPlant: 'banana',
      running: false,
      zombiesToSpawn: 0,
      spawnTimer: 0,
      lastRainTime: 0,
    };
    coinsEl.textContent = state.coins;
    healthEl.textContent = state.health;
    zombiesLeftEl.textContent = `Zombies: 0`;
    waveEl.textContent = `Wave 1 / ${MAX_WAVE}`;
    renderGrid();
    updateToolbarSelection();
    centerMsgEl.style.display = 'none';
  }

  function startGame() {
    state.running = true;
    loadHighScore();
    nextWave();
  }

  // RENDER grid fruits with emojis + hp bars
  function renderGrid() {
    [...gridEl.children].forEach(cell => {
      const r = +cell.dataset.row;
      const c = +cell.dataset.col;
      const plant = state.grid[r][c];
      const hpFill = cell.querySelector('.hpfill');
      if(!plant) {
        cell.textContent = '';
        hpFill.style.width = '0%';
        cell.style.color = 'inherit';
      } else {
        cell.textContent = PLANTS[plant.type].emoji;
        const hpPercent = Math.max(0, (plant.hp / PLANTS[plant.type].hp) * 100);
        hpFill.style.width = hpPercent + '%';
        cell.style.color = 'black';
      }
    });
  }

  // Initialize UI
  buildGrid();
  buildToolbar();
  resetGame();

  // Start loop
  requestAnimationFrame(gameLoop);
})();
</script>
</body>
</html>
