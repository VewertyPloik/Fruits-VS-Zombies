<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>
<title>Fruits vs Zombies ‚Äî Emoji Edition</title>
<style>
  :root{
    --bg:linear-gradient(180deg,#e6fbff,#f2fff9);
    --accent:#2b9fff;
    --muted:#0b2540;
  }
  html,body{height:100%;margin:0;font-family: -apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Helvetica,Arial;}
  body{background:var(--bg);display:flex;align-items:center;justify-content:center;padding:10px;}
  #app{width:100%;max-width:520px;background:rgba(255,255,255,0.9);border-radius:14px;box-shadow:0 12px 40px rgba(6,30,60,0.12);overflow:hidden}
  header{display:flex;justify-content:space-between;align-items:center;padding:10px 12px}
  .title{font-weight:800;color:var(--muted);display:flex;gap:8px;align-items:center}
  .hud{display:flex;gap:12px;align-items:center;font-weight:700;color:#123}
  main{padding:8px}
  .board{position:relative;background:transparent;border-radius:10px;padding:10px;touch-action:none}
  .grid{display:grid;grid-template-rows:repeat(3,1fr);grid-template-columns:repeat(4,1fr);gap:6px}
  .cell{display:flex;flex-direction:column;align-items:center;justify-content:center;min-height:80px;user-select:none}
  .emoji{font-size:36px;line-height:1;pointer-events:none}
  .hpbar{width:56px;height:8px;border-radius:999px;background:rgba(0,0,0,0.08);overflow:hidden;margin-top:6px}
  .hpfill{height:100%;background:linear-gradient(90deg,#34d399,#059669);width:100%}
  .zombieHpBg{width:48px;height:6px;border-radius:999px;background:rgba(0,0,0,0.08);overflow:hidden;margin-top:6px}
  .zombieHpFill{height:100%;background:linear-gradient(90deg,#fb7185,#ef4444);width:100%}
  .toolbar{display:flex;gap:8px;justify-content:center;padding:8px;flex-wrap:wrap}
  .toolBtn{background:transparent;border:none;padding:8px;border-radius:10px;font-size:20px}
  .toolBtn.selected{outline:3px solid rgba(43,159,255,0.18);border-radius:12px}
  .controls{display:flex;gap:8px;justify-content:center;margin-top:8px}
  .btn{background:var(--accent);color:white;padding:8px 12px;border-radius:10px;border:none;font-weight:800}
  .smallBtn{background:#0ea5a5;color:white;padding:6px 10px;border-radius:8px;border:none;font-weight:700}
  .centerMsg{position:absolute;left:50%;transform:translateX(-50%);top:42%;background:rgba(255,255,255,0.95);padding:10px 14px;border-radius:12px;font-weight:900;display:none;z-index:40;box-shadow:0 6px 22px rgba(8,20,40,0.12)}
  footer{display:flex;justify-content:space-between;padding:8px 12px;color:#123;font-weight:600}
  .infoSmall{font-size:13px;color:#234}
  @media (max-width:420px){ .emoji{font-size:30px} .hpbar{width:48px} }
</style>
</head>
<body>
<div id="app">
  <header>
    <div class="title">üçì Fruits vs Zombies</div>
    <div class="hud">
      <div id="wave">Wave 1 / 15</div>
      <div id="zleft">Zombies: 0</div>
      <div id="hp">Health: 5</div>
    </div>
  </header>

  <main>
    <div class="board" id="board" aria-hidden="false">
      <div class="centerMsg" id="centerMsg"></div>
      <div class="grid" id="grid"></div>
      <!-- canvas for projectiles and rain visuals -->
      <canvas id="fx" style="position:absolute;inset:10px;pointer-events:none;z-index:2"></canvas>
    </div>

    <div style="display:flex;justify-content:space-between;align-items:center;margin-top:8px">
      <div class="infoSmall">Coins: üíß <span id="coins">15</span></div>
      <div style="display:flex;gap:8px">
        <button id="pause" class="smallBtn">Pause</button>
        <button id="new" class="smallBtn">New Game</button>
      </div>
    </div>

    <div class="toolbar" id="toolbar" style="margin-top:10px"></div>
    <div class="controls"><button id="help" class="btn">Place: select fruit ‚Üí tap cell</button></div>
  </main>

  <footer>
    <div class="infoSmall">Tap falling üíß to collect. Fruits have 4 HP.</div>
    <div class="infoSmall">High: <span id="high">0</span></div>
  </footer>
</div>

<script>
/* ---------- CONFIG ---------- */
const ROWS = 3, COLS = 4, MAX_WAVE = 15;
const START_COINS = 15, START_HEALTH = 5;
const FRUIT_HP = 4;
const RAIN_INTERVAL = 4000; // ms
const RAIN_VALUE = 1;
const ZOMBIE_BASE_HP = 5;
const ZOMBIE_HP_PER_WAVE = 2;
const ZOMBIE_BASE_SPEED = 0.035; // factor multiplied by canvas width to get px/s
const ZOMBIE_SPEED_MULT_PER_WAVE = 1.08; // 8%
const SPAWN_BASE = 3;
const SPAWN_INC = 3;
const ZOMBIE_BITE_INTERVAL = 0.8; // seconds between bites on a fruit

/* ---------- PLANTS ---------- */
const PLANTS = {
  banana: { key:'banana', emoji:'üçå', cost:10, shootMs:3500, damage:5, hp:FRUIT_HP },
  lemon:  { key:'lemon', emoji:'üçã', cost:8, explodeDmg:25, explodeRange:1, hp:FRUIT_HP },
  watermelon: { key:'watermelon', emoji:'üçâ', cost:5, produceMs:4000, produce:1, hp:FRUIT_HP },
  blueberry: { key:'blueberry', emoji:'ü´ê', cost:25, shootMs:2500, damage:10, hp:FRUIT_HP }
};

/* ---------- STATE ---------- */
let state = {
  wave:1,
  coins: START_COINS,
  health: START_HEALTH,
  grid: Array.from({length:ROWS}, ()=>Array(COLS).fill(null)), // cell: null or plant object {type, hp, lastAct}
  zombies: [], // {x,y,row,hp,maxHp,speed,attacking,targetCol,attackTimer}
  projectiles: [], // {x,y,tx,ty,speed,damage,color,targetRef}
  rain: [], // {x,y,vy}
  selected: 'banana',
  running:false,
  paused:false,
  zombiesToSpawn: 0,
  spawnTimer: 0,
  lastRain: 0,
  lastTime: 0,
  high: 0
};

/* ---------- DOM ---------- */
const gridEl = document.getElementById('grid');
const fx = document.getElementById('fx');
const ctx = fx.getContext('2d');
const coinsEl = document.getElementById('coins');
const hpEl = document.getElementById('hp');
const zleftEl = document.getElementById('zleft');
const waveEl = document.getElementById('wave');
const toolbar = document.getElementById('toolbar');
const centerMsg = document.getElementById('centerMsg');
const pauseBtn = document.getElementById('pause');
const newBtn = document.getElementById('new');
const highEl = document.getElementById('high');

const HIGH_KEY = 'fvz_high_wave';

/* ---------- UTIL ---------- */
function loadHigh(){ state.high = parseInt(localStorage.getItem(HIGH_KEY)||'0',10) || 0; highEl.textContent = state.high; }
function saveHigh(v){ if(v > state.high){ state.high = v; localStorage.setItem(HIGH_KEY, String(v)); highEl.textContent = state.high; } }
function showCenter(msg, sticky=false){
  centerMsg.style.display='block';
  centerMsg.textContent = msg;
  if(!sticky){ clearTimeout(centerMsg._t); centerMsg._t = setTimeout(()=>centerMsg.style.display='none', 900); }
}
function clearCenter(){ centerMsg.style.display='none'; }

/* ---------- GRID UI ---------- */
function buildGrid(){
  gridEl.innerHTML = '';
  for(let r=0;r<ROWS;r++){
    for(let c=0;c<COLS;c++){
      const cell = document.createElement('div');
      cell.className = 'cell';
      cell.dataset.r = r; cell.dataset.c = c;
      const emoji = document.createElement('div'); emoji.className = 'emoji';
      const hpbar = document.createElement('div'); hpbar.className='hpbar';
      const hpfill = document.createElement('div'); hpfill.className='hpfill';
      hpbar.appendChild(hpfill);
      cell.appendChild(emoji); cell.appendChild(hpbar);
      cell.addEventListener('pointerdown', onCellTap);
      gridEl.appendChild(cell);
    }
  }
  resizeCanvas();
  renderGrid();
}
function renderGrid(){
  const children = gridEl.children;
  for(let i=0;i<children.length;i++){
    const r = Math.floor(i/COLS), c = i%COLS;
    const slot = state.grid[r][c];
    const emoji = children[i].querySelector('.emoji');
    const hpfill = children[i].querySelector('.hpfill');
    if(!slot){
      emoji.textContent = '';
      hpfill.style.width = '0%';
    } else {
      emoji.textContent = PLANTS[slot.type].emoji;
      hpfill.style.width = Math.max(0, (slot.hp / slot.maxHp) * 100) + '%';
    }
  }
}

/* ---------- TOOLBAR ---------- */
function buildToolbar(){
  toolbar.innerHTML = '';
  Object.values(PLANTS).forEach(p=>{
    const btn = document.createElement('button');
    btn.className = 'toolBtn';
    btn.dataset.type = p.key;
    btn.innerHTML = `${p.emoji}<div style="font-size:12px">${p.cost}üíß</div>`;
    btn.addEventListener('click', ()=> { state.selected = p.key; updateToolbar(); });
    toolbar.appendChild(btn);
  });
  updateToolbar();
}
function updateToolbar(){
  document.querySelectorAll('.toolBtn').forEach(b=>b.classList.remove('selected'));
  const chosen = document.querySelector(`.toolBtn[data-type="${state.selected}"]`);
  if(chosen) chosen.classList.add('selected');
}

/* ---------- CELL TAP (place plant) ---------- */
function onCellTap(ev){
  if(!state.running || state.paused) return;
  const r = +this.dataset.r, c = +this.dataset.c;
  if(state.grid[r][c]){
    // remove plant (no refund)
    state.grid[r][c] = null;
    renderGrid();
    return;
  }
  const plantDef = PLANTS[state.selected];
  if(!plantDef) return;
  if(state.coins < plantDef.cost){ showCenter('Not enough üíß'); return; }
  // place
  state.coins -= plantDef.cost; coinsEl.textContent = state.coins;
  state.grid[r][c] = { type: plantDef.key, hp: plantDef.hp, maxHp: plantDef.hp, lastAct: performance.now() };
  renderGrid();
}

/* ---------- CANVAS / SIZING ---------- */
function resizeCanvas(){
  const boardRect = document.getElementById('board').getBoundingClientRect();
  const inset = 20; // because canvas is inset by 10 left/right in CSS
  const w = Math.max(240, boardRect.width - inset);
  const h = Math.max(220, w * 0.68);
  fx.style.width = w + 'px';
  fx.style.height = h + 'px';
  fx.width = Math.round(w);
  fx.height = Math.round(h);
  // update monsters' px speeds to new width
  state.zombies.forEach(z=> {
    const stats = zombieStatsForWave(state.wave);
    z.speed = stats.speed * fx.width;
  });
}

/* ---------- SPAWN & WAVE LOGIC ---------- */
function zombieStatsForWave(w){
  const hp = ZOMBIE_BASE_HP + ZOMBIE_HP_PER_WAVE * (w - 1);
  const speedFactor = ZOMBIE_BASE_SPEED * Math.pow(ZOMBIE_SPEED_MULT_PER_WAVE, w - 1);
  return { hp, speed: speedFactor };
}
function startWaveSetup(){
  // set zombies to spawn: SPAWN_BASE + (wave-1)*SPAWN_INC
  state.zombiesToSpawn = SPAWN_BASE + (state.wave - 1) * SPAWN_INC;
  state.spawnTimer = 0;
  showCenter('Wave ' + state.wave + ' start');
}
function trySpawn(dt){
  if(state.zombiesToSpawn <= 0) return;
  state.spawnTimer += dt;
  const spawnInterval = Math.max(0.5, 1.4 - state.wave * 0.03);
  if(state.spawnTimer >= spawnInterval){
    spawnOne();
    state.zombiesToSpawn--;
    state.spawnTimer = 0;
  }
}
function spawnOne(){
  const stats = zombieStatsForWave(state.wave);
  const row = Math.floor(Math.random() * ROWS);
  const rect = fx.getBoundingClientRect();
  const x = fx.width + 20;
  const y = (row + 0.5) * (fx.height / ROWS);
  state.zombies.push({ x, y, row, hp: stats.hp, maxHp: stats.hp, speed: stats.speed * fx.width, attacking:false, attackTimer:0, targetCol:null });
}

/* ---------- RAIN ---------- */
function spawnRain(){
  const x = 10 + Math.random() * (fx.width - 20);
  state.rain.push({ x, y: -12, vy: 80 + Math.random() * 60 });
}
function updateRain(dt){
  for(let i = state.rain.length -1; i >= 0; i--){
    const d = state.rain[i];
    d.y += d.vy * dt;
    if(d.y > fx.height + 30) state.rain.splice(i,1);
  }
}

/* ---------- PROJECTILES ---------- */
function fireProjectile(fromX, fromY, target, dmg, color){
  if(!target) return;
  state.projectiles.push({ x: fromX, y: fromY, tx: target.x, ty: target.y, speed: 380, damage: dmg, color, targetRef: target });
}

/* ---------- MAIN LOOP ---------- */
let lastTs = 0;
function loop(ts){
  if(!state.running) return;
  if(state.paused){ lastTs = ts; requestAnimationFrame(loop); return; }
  if(!lastTs) lastTs = ts;
  const dt = (ts - lastTs) / 1000; // seconds
  lastTs = ts;

  // spawn rain every RAIN_INTERVAL
  if(ts - state.lastRain > RAIN_INTERVAL){ spawnRain(); state.lastRain = ts; }

  // spawn zombies
  trySpawn(dt);

  // update rain
  updateRain(dt);

  // update projectiles
  for(let i = state.projectiles.length -1; i>=0; i--){
    const p = state.projectiles[i];
    const dx = p.tx - p.x, dy = p.ty - p.y;
    const dist = Math.hypot(dx,dy);
    const step = p.speed * dt;
    if(dist <= step || isNaN(dist)){
      // hit
      if(p.targetRef && p.targetRef.hp > 0) p.targetRef.hp -= p.damage;
      state.projectiles.splice(i,1);
    } else {
      p.x += dx / dist * step;
      p.y += dy / dist * step;
    }
  }

  // update zombies
  for(let zi = state.zombies.length -1; zi >= 0; zi--){
    const z = state.zombies[zi];
    if(z.attacking){
      z.attackTimer += dt;
      if(z.attackTimer >= ZOMBIE_BITE_INTERVAL){
        z.attackTimer = 0;
        const col = z.targetCol;
        const plant = state.grid[z.row][col];
        if(plant){
          plant.hp -= 1;
          if(plant.hp <= 0){
            state.grid[z.row][col] = null;
            renderGrid();
            z.attacking = false;
            z.targetCol = null;
          }
        } else {
          z.attacking = false;
          z.targetCol = null;
        }
      }
      continue;
    }
    // move left
    z.x -= z.speed * dt;
    // which column is z approaching?
    const colWidth = fx.width / COLS;
    const col = Math.min(COLS - 1, Math.max(0, Math.floor(z.x / colWidth)));
    // check plant in the column (closest to left edge)
    if(col >= 0 && col < COLS){
      const plant = state.grid[z.row][col];
      if(plant){
        // compute cell center x
        const cc = cellCenter(z.row, col);
        const stopX = cc.x + colWidth * 0.45; // stop near front of the plant
        if(z.x <= stopX + 6){
          // begin attacking
          z.attacking = true;
          z.targetCol = col;
          z.attackTimer = 0;
          continue;
        }
      }
    }
    // check if passed left edge
    if(z.x < -20){
      state.zombies.splice(zi,1);
      state.health -= 1;
      hpEl.textContent = 'Health: ' + state.health;
      if(state.health <= 0){ // game over
        saveHigh(state.wave);
        endGame(false);
        return;
      }
    }
  }

  // automatic plant actions
  const now = performance.now();
  for(let r=0;r<ROWS;r++){
    for(let c=0;c<COLS;c++){
      const slot = state.grid[r][c];
      if(!slot) continue;
      const def = PLANTS[slot.type];
      // shooting
      if(def.shootMs){
        if(!slot._lastShoot) slot._lastShoot = now;
        if(now - slot._lastShoot >= def.shootMs){
          // find target in same row else any
          let target = null;
          for(const z of state.zombies){ if(z.row === r && z.hp > 0){ target = z; break; } }
          if(!target && state.zombies.length) target = state.zombies[Math.floor(Math.random()*state.zombies.length)];
          if(target){
            const cc = cellCenter(r,c);
            fireProjectile(cc.x, cc.y, target, def.damage, slot.type === 'blueberry' ? 'blue' : 'yellow');
          }
          slot._lastShoot = now;
        }
      }
      // produce (watermelon)
      if(def.produceMs){
        if(!slot._lastProduce) slot._lastProduce = now;
        if(now - slot._lastProduce >= def.produceMs){
          state.coins += def.produce;
          coinsEl.textContent = state.coins;
          slot._lastProduce = now;
        }
      }
    }
  }

  // lemons: explode if zombie within 1-grid Chebyshev distance
  for(let r=0;r<ROWS;r++){
    for(let c=0;c<COLS;c++){
      const slot = state.grid[r][c];
      if(!slot || slot.type !== 'lemon') continue;
      const cc = cellCenter(r,c);
      const diagPx = Math.max(fx.width/COLS, fx.height/ROWS) * 1.05;
      let exploded = false;
      for(let zi = state.zombies.length -1; zi >= 0; zi--){
        const z = state.zombies[zi];
        const dx = z.x - cc.x, dy = z.y - cc.y;
        if(Math.hypot(dx,dy) <= diagPx){
          // explode: damage all zombies within diagPx
          for(const z2 of state.zombies){
            const dx2 = z2.x - cc.x, dy2 = z2.y - cc.y;
            if(Math.hypot(dx2,dy2) <= diagPx){
              z2.hp -= PLANTS.lemon.explodeDmg;
            }
          }
          // remove lemon
          state.grid[r][c] = null;
          exploded = true;
          renderGrid();
          break;
        }
      }
      if(exploded) break;
    }
  }

  // remove dead zombies (no coin reward to keep pace)
  for(let i=state.zombies.length -1;i>=0;i--){
    if(state.zombies[i].hp <= 0) state.zombies.splice(i,1);
  }

  // HUD update
  zleftEl.textContent = 'Zombies: ' + (state.zombies.length + Math.max(0, state.zombiesToSpawn));
  waveEl.textContent = `Wave ${state.wave} / ${MAX_WAVE}`;
  coinsEl.textContent = state.coins;
  hpEl.textContent = 'Health: ' + state.health;

  // draw
  drawScene();

  // if wave cleared, prepare next wave
  if(state.zombies.length === 0 && state.zombiesToSpawn === 0){
    // Completed wave
    if(state.wave >= MAX_WAVE){
      saveHigh(state.wave);
      showCenter('YOU WON!', true);
      endGame(true); return;
    } else {
      showCenter(`Wave ${state.wave} completed!`);
      // small pause then next wave
      setTimeout(()=> {
        clearCenter();
        state.wave++;
        state.zombiesToSpawn = SPAWN_BASE + (state.wave - 1) * SPAWN_INC;
        state.spawnTimer = 0;
        // coin bonus
        state.coins += 5;
        coinsEl.textContent = state.coins;
        showCenter('Wave ' + state.wave + ' start');
      }, 900);
    }
  }

  requestAnimationFrame(loop);
}

/* ---------- DRAW ---------- */
function drawScene(){
  resizeCanvasIfNeeded();
  ctx.clearRect(0,0,fx.width,fx.height);

  // rain
  for(const d of state.rain){
    ctx.beginPath();
    ctx.ellipse(d.x, d.y, 9, 12, 0, 0, Math.PI*2);
    ctx.fillStyle = '#6ec6ff'; ctx.fill();
    ctx.font = '12px serif';
    ctx.fillText('üíß', d.x-6, d.y+4);
  }

  // projectiles
  for(const p of state.projectiles){
    ctx.beginPath();
    ctx.fillStyle = p.color === 'blue' ? '#3b82f6' : '#facc15';
    ctx.arc(p.x, p.y, 6, 0, Math.PI*2);
    ctx.fill();
  }

  // zombies (emoji + hp bar below)
  ctx.font = Math.max(18, fx.width/18) + 'px serif';
  ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
  for(const z of state.zombies){
    ctx.fillText('üßü', z.x, z.y);
    const bw = Math.min(44, fx.width/10);
    const bx = z.x - bw/2; const by = z.y + 28;
    ctx.fillStyle = 'rgba(0,0,0,0.08)'; ctx.fillRect(bx, by, bw, 6);
    ctx.fillStyle = '#ef4444'; ctx.fillRect(bx, by, Math.max(0, (z.hp / z.maxHp) * bw), 6);
    ctx.strokeStyle = 'rgba(0,0,0,0.12)'; ctx.strokeRect(bx, by, bw, 6);
  }
}

/* ---------- HELPERS ---------- */
function cellCenter(r,c){
  const w = fx.width / COLS, h = fx.height / ROWS;
  return { x: (c + 0.5) * w, y: (r + 0.5) * h, w, h };
}
function resizeCanvasIfNeeded(){
  const boardRect = document.getElementById('board').getBoundingClientRect();
  const desiredW = Math.max(240, boardRect.width - 20);
  const desiredH = Math.max(220, desiredW * 0.68);
  if(fx.width !== Math.round(desiredW) || fx.height !== Math.round(desiredH)){
    fx.style.width = desiredW + 'px'; fx.style.height = desiredH + 'px';
    fx.width = Math.round(desiredW); fx.height = Math.round(desiredH);
    // update zombie speeds to new width
    state.zombies.forEach(z => { z.speed = zombieStatsForWave(state.wave).speed * fx.width; });
  }
}

/* ---------- RAIN CLICK TO COLLECT ---------- */
fx.addEventListener('pointerdown', (ev)=>{
  const rect = fx.getBoundingClientRect();
  const x = ev.clientX - rect.left, y = ev.clientY - rect.top;
  for(let i = state.rain.length -1; i >= 0; i--){
    const d = state.rain[i];
    const dx = d.x - x, dy = d.y - y;
    if(Math.hypot(dx,dy) < 22){
      state.coins += RAIN_VALUE; coinsEl.textContent = state.coins;
      state.rain.splice(i,1);
      showCenter('+1 üíß');
      return;
    }
  }
});

/* ---------- ENDGAME ---------- */
function endGame(won){
  state.running = false;
  clearCenter();
  if(won) showCenter('YOU WON! üéâ', true);
  else showCenter('Game Over', true);
  saveHigh(state.wave);
  setTimeout(()=>{ centerMsg.style.display='none'; }, 1500);
}

/* ---------- INIT & START ---------- */
function init(){
  loadHigh();
  buildToolbar();
  buildGrid();
  coinsEl.textContent = state.coins;
  hpEl.textContent = 'Health: ' + state.health;
  // initial wave spawn config
  state.zombiesToSpawn = SPAWN_BASE + (state.wave - 1) * SPAWN_INC;
  state.lastRain = performance.now();
  state.running = true;
  state.paused = false;
  requestAnimationFrame((t)=>{ lastTs = t; loop(t); });
  // periodic update for rain falling and spawn tick rates
  setInterval(()=>{
    if(!state.running || state.paused) return;
    const now = performance.now();
    const dt = 60/1000; // we'll update rain positions relative to frame loop; but spawn handled in main loop
    for(let i = state.rain.length -1; i >= 0; i--){
      const d = state.rain[i];
      d.y += d.vy * dt;
      if(d.y > fx.height + 30) state.rain.splice(i,1);
    }
  }, 60);
  // spawn rain regularly using timer
  setInterval(()=>{ if(state.running && !state.paused) spawnRain(); }, RAIN_INTERVAL);
  // button handlers
  pauseBtn.addEventListener('click', ()=>{ state.paused = !state.paused; pauseBtn.textContent = state.paused ? 'Resume' : 'Pause'; });
  newBtn.addEventListener('click', ()=>{ startFresh(); });
}
function startFresh(){
  // reset game but keep high score
  state.wave = 1; state.coins = START_COINS; state.health = START_HEALTH;
  state.grid = Array.from({length:ROWS}, ()=>Array(COLS).fill(null));
  state.zombies = []; state.projectiles = []; state.rain = [];
  state.selected = 'banana';
  state.zombiesToSpawn = SPAWN_BASE + (state.wave - 1) * SPAWN_INC;
  state.spawnTimer = 0;
  coinsEl.textContent = state.coins;
  hpEl.textContent = 'Health: ' + state.health;
  buildGrid(); buildToolbar();
  state.running = true; state.paused = false;
  showCenter('Wave 1 start');
}

/* ---------- Start ---------- */
init();

/* ---------- Events: place via toolbar selection ---------- */
document.addEventListener('click', (e)=>{
  // clicking toolbar is handled; help button no-op
});
</script>
</body>
</html>
